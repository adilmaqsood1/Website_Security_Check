"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_utils_pdfGenerator_ts",{

/***/ "./src/utils/pdfGenerator.ts":
/*!***********************************!*\
  !*** ./src/utils/pdfGenerator.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generatePDFReport: function() { return /* binding */ generatePDFReport; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n\n\n/**\n * Generate a PDF report from scan data\n * @param scan The scan details\n * @param vulnerabilities List of vulnerabilities found in the scan\n * @returns Blob containing the PDF document\n */ const generatePDFReport = function(scan) {\n    let vulnerabilities = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    // Initialize PDF document\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__.jsPDF();\n    const pageWidth = doc.internal.pageSize.getWidth();\n    // Add report title\n    doc.setFontSize(20);\n    doc.setTextColor(0, 51, 102); // Dark blue color\n    doc.text(\"Website Security Scan Report\", pageWidth / 2, 20, {\n        align: \"center\"\n    });\n    // Add scan information\n    doc.setFontSize(12);\n    doc.setTextColor(0, 0, 0); // Black color\n    doc.text(\"URL: \".concat(scan.url || scan.target || \"N/A\"), 14, 35);\n    doc.text(\"Scan Type: \".concat(scan.scan_type ? scan.scan_type.charAt(0).toUpperCase() + scan.scan_type.slice(1) : \"N/A\"), 14, 42);\n    doc.text(\"Status: \".concat(scan.status.charAt(0).toUpperCase() + scan.status.slice(1)), 14, 49);\n    doc.text(\"Date: \".concat(scan.created_at ? new Date(scan.created_at).toLocaleString() : \"N/A\"), 14, 56);\n    // Handle different time field names\n    const startTimeValue = scan.start_time || scan.started_at;\n    const endTimeValue = scan.end_time || scan.completed_at;\n    if (startTimeValue && endTimeValue) {\n        const startTime = new Date(startTimeValue);\n        const endTime = new Date(endTimeValue);\n        doc.text(\"Duration: \".concat(((endTime.getTime() - startTime.getTime()) / 1000 / 60).toFixed(2), \" minutes\"), 14, 63);\n    }\n    // Add summary section\n    doc.setFontSize(16);\n    doc.setTextColor(0, 51, 102); // Dark blue color\n    doc.text(\"Summary\", 14, 75);\n    if (scan.summary) {\n        doc.setFontSize(12);\n        doc.setTextColor(0, 0, 0); // Black color\n        doc.text(\"Total Vulnerabilities: \".concat(scan.summary.total_vulnerabilities), 14, 85);\n        // Add severity counts\n        if (scan.summary.severity_counts) {\n            const severityCounts = scan.summary.severity_counts;\n            // Create a table for severity counts\n            (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n                startY: 95,\n                head: [\n                    [\n                        \"Severity\",\n                        \"Count\"\n                    ]\n                ],\n                body: [\n                    [\n                        \"Critical\",\n                        severityCounts.critical.toString()\n                    ],\n                    [\n                        \"High\",\n                        severityCounts.high.toString()\n                    ],\n                    [\n                        \"Medium\",\n                        severityCounts.medium.toString()\n                    ],\n                    [\n                        \"Low\",\n                        severityCounts.low.toString()\n                    ],\n                    [\n                        \"Info\",\n                        severityCounts.info.toString()\n                    ]\n                ],\n                theme: \"striped\",\n                headStyles: {\n                    fillColor: [\n                        0,\n                        51,\n                        102\n                    ]\n                },\n                columnStyles: {\n                    0: {\n                        cellWidth: 40\n                    },\n                    1: {\n                        cellWidth: 40,\n                        halign: \"center\"\n                    }\n                }\n            });\n        }\n    }\n    // Add vulnerabilities section if there are any\n    if (vulnerabilities.length > 0) {\n        // Get the position after the last table or use default value\n        const currentY = doc.previousAutoTable ? doc.previousAutoTable.finalY + 15 : 150;\n        doc.setFontSize(16);\n        doc.setTextColor(0, 51, 102); // Dark blue color\n        doc.text(\"Vulnerabilities\", 14, currentY);\n        // Create a table for vulnerabilities\n        const tableRows = vulnerabilities.map((vuln)=>[\n                vuln.name,\n                vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1),\n                vuln.location,\n                vuln.description.length > 50 ? vuln.description.substring(0, 50) + \"...\" : vuln.description\n            ]);\n        (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n            startY: currentY + 10,\n            head: [\n                [\n                    \"Name\",\n                    \"Severity\",\n                    \"Location\",\n                    \"Description\"\n                ]\n            ],\n            body: tableRows,\n            theme: \"striped\",\n            headStyles: {\n                fillColor: [\n                    0,\n                    51,\n                    102\n                ]\n            },\n            columnStyles: {\n                0: {\n                    cellWidth: 40\n                },\n                1: {\n                    cellWidth: 30\n                },\n                2: {\n                    cellWidth: 40\n                },\n                3: {\n                    cellWidth: \"auto\"\n                }\n            },\n            didDrawPage: (data)=>{\n                // Add page number at the bottom\n                const pageNumber = doc.getNumberOfPages();\n                doc.setFontSize(10);\n                doc.text(\"Page \".concat(pageNumber), pageWidth - 20, doc.internal.pageSize.getHeight() - 10);\n            }\n        });\n        // Add detailed vulnerability information\n        vulnerabilities.forEach((vuln, index)=>{\n            doc.addPage();\n            // Add page number\n            const pageNumber = doc.getNumberOfPages();\n            doc.setFontSize(10);\n            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, doc.internal.pageSize.getHeight() - 10);\n            // Add vulnerability details\n            doc.setFontSize(16);\n            doc.setTextColor(0, 51, 102); // Dark blue color\n            doc.text(\"Vulnerability #\".concat(index + 1, \": \").concat(vuln.name), 14, 20);\n            doc.setFontSize(12);\n            doc.setTextColor(0, 0, 0); // Black color\n            doc.text(\"Severity: \".concat(vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1)), 14, 30);\n            doc.text(\"Location: \".concat(vuln.location), 14, 37);\n            if (vuln.cwe_id) {\n                doc.text(\"CWE ID: \".concat(vuln.cwe_id), 14, 44);\n            }\n            if (vuln.cvss_score) {\n                doc.text(\"CVSS Score: \".concat(vuln.cvss_score), 14, 51);\n            }\n            // Description with word wrap\n            doc.setFontSize(12);\n            doc.text(\"Description:\", 14, 58);\n            const splitDescription = doc.splitTextToSize(vuln.description, pageWidth - 28);\n            doc.text(splitDescription, 14, 65);\n            let currentYPosition = 65 + splitDescription.length * 7;\n            // Evidence with word wrap if available\n            if (vuln.evidence) {\n                doc.text(\"Evidence:\", 14, currentYPosition);\n                const splitEvidence = doc.splitTextToSize(vuln.evidence, pageWidth - 28);\n                doc.text(splitEvidence, 14, currentYPosition + 7);\n                currentYPosition += 7 + splitEvidence.length * 7;\n            }\n            // Enhanced remediation section with structured format\n            if (vuln.remediation) {\n                // Main remediation heading\n                doc.setFontSize(14);\n                doc.setTextColor(0, 51, 102); // Dark blue color\n                doc.text(\"Remediation:\", 14, currentYPosition);\n                currentYPosition += 10;\n                // Reset to normal text style\n                doc.setFontSize(12);\n                doc.setTextColor(0, 0, 0); // Black color\n                // Parse the remediation text to identify sections and clean markdown formatting\n                let remediationText = vuln.remediation;\n                // Remove markdown header formatting (### and ####)\n                remediationText = remediationText.replace(/^###\\s+/gm, \"\");\n                // Check if the remediation text contains structured sections\n                if (remediationText.includes(\"1. Importance of Fixing\") || remediationText.includes(\"#### 1. Importance of Fixing\")) {\n                    // For structured remediation format - remove markdown headers and clean up formatting\n                    // First remove any remaining markdown headers\n                    remediationText = remediationText.replace(/####\\s+/gm, \"\");\n                    // Split by section numbers (1., 2., etc.)\n                    const sections = remediationText.split(/\\d+\\.\\s+/);\n                    let currentSection = \"\";\n                    let sectionY = currentYPosition;\n                    // Process each section after the split (skip the first empty element if exists)\n                    for(let i = 0; i < sections.length; i++){\n                        if (sections[i].trim() === \"\") continue;\n                        // Extract section title and content\n                        const sectionParts = sections[i].split(\"\\n\");\n                        // Clean up any remaining markdown formatting from section title\n                        const sectionTitle = sectionParts[0].trim().replace(/^#+\\s*/g, \"\");\n                        const sectionContent = sectionParts.slice(1).join(\"\\n\").trim();\n                        // Add section title with bold styling\n                        doc.setFont(\"helvetica\", \"bold\");\n                        doc.text(sectionTitle, 14, sectionY);\n                        doc.setFont(\"helvetica\", \"normal\");\n                        sectionY += 7;\n                        // Add section content with proper formatting\n                        const splitContent = doc.splitTextToSize(sectionContent, pageWidth - 28);\n                        // Check if we need to add a new page\n                        if (sectionY + splitContent.length * 7 > doc.internal.pageSize.getHeight() - 20) {\n                            doc.addPage();\n                            sectionY = 20;\n                            // Add page number\n                            const pageNumber = doc.getNumberOfPages();\n                            doc.setFontSize(10);\n                            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, doc.internal.pageSize.getHeight() - 10);\n                            doc.setFontSize(12);\n                        }\n                        // Handle code examples with special formatting\n                        if (sectionContent.includes(\"```\")) {\n                            const contentParts = sectionContent.split(/```\\w*\\n/);\n                            let contentY = sectionY;\n                            for(let j = 0; j < contentParts.length; j++){\n                                if (j % 2 === 0) {\n                                    // Regular text\n                                    const regularText = contentParts[j].trim();\n                                    if (regularText) {\n                                        const splitRegular = doc.splitTextToSize(regularText, pageWidth - 28);\n                                        doc.text(splitRegular, 14, contentY);\n                                        contentY += splitRegular.length * 7;\n                                    }\n                                } else {\n                                    // Code example\n                                    const codeText = contentParts[j].split(\"```\")[0].trim();\n                                    if (codeText) {\n                                        // Draw a light gray background for code\n                                        doc.setFillColor(240, 240, 240);\n                                        const splitCode = doc.splitTextToSize(codeText, pageWidth - 40);\n                                        doc.rect(14, contentY - 5, pageWidth - 28, splitCode.length * 7 + 10, \"F\");\n                                        // Add the code with monospace font\n                                        doc.setFont(\"courier\", \"normal\");\n                                        doc.text(splitCode, 20, contentY);\n                                        doc.setFont(\"helvetica\", \"normal\");\n                                        contentY += splitCode.length * 7 + 10;\n                                    }\n                                }\n                            }\n                            sectionY = contentY + 10;\n                        } else {\n                            // Regular text without code examples\n                            doc.text(splitContent, 14, sectionY);\n                            sectionY += splitContent.length * 7 + 10;\n                        }\n                    }\n                    currentYPosition = sectionY;\n                } else {\n                    // For simple unstructured remediation text\n                    // Clean up any markdown formatting from unstructured text\n                    remediationText = remediationText.replace(/^###\\s+/gm, \"\");\n                    remediationText = remediationText.replace(/^####\\s+/gm, \"\");\n                    remediationText = remediationText.replace(/^#\\s+/gm, \"\");\n                    const splitRemediation = doc.splitTextToSize(remediationText, pageWidth - 28);\n                    doc.text(splitRemediation, 14, currentYPosition);\n                    currentYPosition += splitRemediation.length * 7;\n                }\n            }\n        });\n    }\n    // Add footer with generation date\n    const pageCount = doc.getNumberOfPages();\n    for(let i = 1; i <= pageCount; i++){\n        doc.setPage(i);\n        doc.setFontSize(10);\n        doc.setTextColor(100, 100, 100); // Gray color\n        doc.text(\"Report generated on \".concat(new Date().toLocaleString()), 14, doc.internal.pageSize.getHeight() - 10);\n    }\n    // Return the PDF as a blob\n    return doc.output(\"blob\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLGtDQUFrQztJQUNsQyxNQUFNcUQsWUFBWXJHLElBQUkrRCxnQkFBZ0I7SUFDdEMsSUFBSyxJQUFJb0IsSUFBSSxHQUFHQSxLQUFLa0IsV0FBV2xCLElBQUs7UUFDbkNuRixJQUFJc0csT0FBTyxDQUFDbkI7UUFDWm5GLElBQUlLLFdBQVcsQ0FBQztRQUNoQkwsSUFBSU0sWUFBWSxDQUFDLEtBQUssS0FBSyxNQUFNLGFBQWE7UUFDOUNOLElBQUlPLElBQUksQ0FBQyx1QkFBbUQsT0FBNUIsSUFBSVUsT0FBT0MsY0FBYyxLQUFNLElBQUlsQixJQUFJRSxRQUFRLENBQUNDLFFBQVEsQ0FBQzZELFNBQVMsS0FBSztJQUN6RztJQUVBLDJCQUEyQjtJQUMzQixPQUFPaEUsSUFBSXVHLE1BQU0sQ0FBQztBQUNwQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9wZGZHZW5lcmF0b3IudHM/ZGMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc1BERiB9IGZyb20gJ2pzcGRmJztcbmltcG9ydCBhdXRvVGFibGUgZnJvbSAnanNwZGYtYXV0b3RhYmxlJztcblxuaW50ZXJmYWNlIFNldmVyaXR5Q291bnRzIHtcbiAgY3JpdGljYWw6IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBtZWRpdW06IG51bWJlcjtcbiAgbG93OiBudW1iZXI7XG4gIGluZm86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNjYW5TdW1tYXJ5IHtcbiAgdG90YWxfdnVsbmVyYWJpbGl0aWVzOiBudW1iZXI7XG4gIHNldmVyaXR5X2NvdW50czogU2V2ZXJpdHlDb3VudHM7XG4gIHNjYW5fZHVyYXRpb24/OiBudW1iZXI7XG4gIHBhZ2VzX3NjYW5uZWQ/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBWdWxuZXJhYmlsaXR5IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBzZXZlcml0eTogc3RyaW5nO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICBldmlkZW5jZT86IHN0cmluZztcbiAgcmVtZWRpYXRpb24/OiBzdHJpbmc7XG4gIGN3ZV9pZD86IHN0cmluZztcbiAgY3Zzc19zY29yZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNjYW5EZXRhaWxzIHtcbiAgaWQ6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICB0YXJnZXQ/OiBzdHJpbmc7IC8vIEFkZGVkIHRhcmdldCBmaWVsZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byB1cmxcbiAgc2Nhbl90eXBlPzogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgc3RhcnRlZF9hdD86IHN0cmluZzsgLy8gQWRkZWQgc3RhcnRlZF9hdCBmaWVsZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBzdGFydF90aW1lXG4gIGNvbXBsZXRlZF9hdD86IHN0cmluZzsgLy8gQWRkZWQgY29tcGxldGVkX2F0IGZpZWxkIGFzIGFuIGFsdGVybmF0aXZlIHRvIGVuZF90aW1lXG4gIHN0YXJ0X3RpbWU/OiBzdHJpbmcgfCBudWxsO1xuICBlbmRfdGltZT86IHN0cmluZyB8IG51bGw7XG4gIHN1bW1hcnk6IFNjYW5TdW1tYXJ5IHwgbnVsbDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFBERiByZXBvcnQgZnJvbSBzY2FuIGRhdGFcbiAqIEBwYXJhbSBzY2FuIFRoZSBzY2FuIGRldGFpbHNcbiAqIEBwYXJhbSB2dWxuZXJhYmlsaXRpZXMgTGlzdCBvZiB2dWxuZXJhYmlsaXRpZXMgZm91bmQgaW4gdGhlIHNjYW5cbiAqIEByZXR1cm5zIEJsb2IgY29udGFpbmluZyB0aGUgUERGIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVBERlJlcG9ydCA9IChzY2FuOiBTY2FuRGV0YWlscywgdnVsbmVyYWJpbGl0aWVzOiBWdWxuZXJhYmlsaXR5W10gPSBbXSk6IEJsb2IgPT4ge1xuICAvLyBJbml0aWFsaXplIFBERiBkb2N1bWVudFxuICBjb25zdCBkb2MgPSBuZXcganNQREYoKTtcbiAgY29uc3QgcGFnZVdpZHRoID0gZG9jLmludGVybmFsLnBhZ2VTaXplLmdldFdpZHRoKCk7XG4gIFxuICAvLyBBZGQgcmVwb3J0IHRpdGxlXG4gIGRvYy5zZXRGb250U2l6ZSgyMCk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMCwgNTEsIDEwMik7IC8vIERhcmsgYmx1ZSBjb2xvclxuICBkb2MudGV4dCgnV2Vic2l0ZSBTZWN1cml0eSBTY2FuIFJlcG9ydCcsIHBhZ2VXaWR0aCAvIDIsIDIwLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcbiAgXG4gIC8vIEFkZCBzY2FuIGluZm9ybWF0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7IC8vIEJsYWNrIGNvbG9yXG4gIGRvYy50ZXh0KGBVUkw6ICR7c2Nhbi51cmwgfHwgc2Nhbi50YXJnZXQgfHwgJ04vQSd9YCwgMTQsIDM1KTtcbiAgZG9jLnRleHQoYFNjYW4gVHlwZTogJHtzY2FuLnNjYW5fdHlwZSA/IHNjYW4uc2Nhbl90eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2Nhbi5zY2FuX3R5cGUuc2xpY2UoMSkgOiAnTi9BJ31gLCAxNCwgNDIpO1xuICBkb2MudGV4dChgU3RhdHVzOiAke3NjYW4uc3RhdHVzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2Nhbi5zdGF0dXMuc2xpY2UoMSl9YCwgMTQsIDQ5KTtcbiAgZG9jLnRleHQoYERhdGU6ICR7c2Nhbi5jcmVhdGVkX2F0ID8gbmV3IERhdGUoc2Nhbi5jcmVhdGVkX2F0KS50b0xvY2FsZVN0cmluZygpIDogJ04vQSd9YCwgMTQsIDU2KTtcbiAgXG4gIC8vIEhhbmRsZSBkaWZmZXJlbnQgdGltZSBmaWVsZCBuYW1lc1xuICBjb25zdCBzdGFydFRpbWVWYWx1ZSA9IHNjYW4uc3RhcnRfdGltZSB8fCBzY2FuLnN0YXJ0ZWRfYXQ7XG4gIGNvbnN0IGVuZFRpbWVWYWx1ZSA9IHNjYW4uZW5kX3RpbWUgfHwgc2Nhbi5jb21wbGV0ZWRfYXQ7XG4gIFxuICBpZiAoc3RhcnRUaW1lVmFsdWUgJiYgZW5kVGltZVZhbHVlKSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lVmFsdWUpO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShlbmRUaW1lVmFsdWUpO1xuICAgIGRvYy50ZXh0KGBEdXJhdGlvbjogJHsoKGVuZFRpbWUuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwIC8gNjApLnRvRml4ZWQoMil9IG1pbnV0ZXNgLCAxNCwgNjMpO1xuICB9XG4gIFxuICAvLyBBZGQgc3VtbWFyeSBzZWN0aW9uXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMCwgNTEsIDEwMik7IC8vIERhcmsgYmx1ZSBjb2xvclxuICBkb2MudGV4dCgnU3VtbWFyeScsIDE0LCA3NSk7XG4gIFxuICBpZiAoc2Nhbi5zdW1tYXJ5KSB7XG4gICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApOyAvLyBCbGFjayBjb2xvclxuICAgIGRvYy50ZXh0KGBUb3RhbCBWdWxuZXJhYmlsaXRpZXM6ICR7c2Nhbi5zdW1tYXJ5LnRvdGFsX3Z1bG5lcmFiaWxpdGllc31gLCAxNCwgODUpO1xuICAgIFxuICAgIC8vIEFkZCBzZXZlcml0eSBjb3VudHNcbiAgICBpZiAoc2Nhbi5zdW1tYXJ5LnNldmVyaXR5X2NvdW50cykge1xuICAgICAgY29uc3Qgc2V2ZXJpdHlDb3VudHMgPSBzY2FuLnN1bW1hcnkuc2V2ZXJpdHlfY291bnRzO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSB0YWJsZSBmb3Igc2V2ZXJpdHkgY291bnRzXG4gICAgICBhdXRvVGFibGUoZG9jLCB7XG4gICAgICAgIHN0YXJ0WTogOTUsXG4gICAgICAgIGhlYWQ6IFtbJ1NldmVyaXR5JywgJ0NvdW50J11dLFxuICAgICAgICBib2R5OiBbXG4gICAgICAgICAgWydDcml0aWNhbCcsIHNldmVyaXR5Q291bnRzLmNyaXRpY2FsLnRvU3RyaW5nKCldLFxuICAgICAgICAgIFsnSGlnaCcsIHNldmVyaXR5Q291bnRzLmhpZ2gudG9TdHJpbmcoKV0sXG4gICAgICAgICAgWydNZWRpdW0nLCBzZXZlcml0eUNvdW50cy5tZWRpdW0udG9TdHJpbmcoKV0sXG4gICAgICAgICAgWydMb3cnLCBzZXZlcml0eUNvdW50cy5sb3cudG9TdHJpbmcoKV0sXG4gICAgICAgICAgWydJbmZvJywgc2V2ZXJpdHlDb3VudHMuaW5mby50b1N0cmluZygpXVxuICAgICAgICBdLFxuICAgICAgICB0aGVtZTogJ3N0cmlwZWQnLFxuICAgICAgICBoZWFkU3R5bGVzOiB7IGZpbGxDb2xvcjogWzAsIDUxLCAxMDJdIH0sXG4gICAgICAgIGNvbHVtblN0eWxlczoge1xuICAgICAgICAgIDA6IHsgY2VsbFdpZHRoOiA0MCB9LFxuICAgICAgICAgIDE6IHsgY2VsbFdpZHRoOiA0MCwgaGFsaWduOiAnY2VudGVyJyB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQWRkIHZ1bG5lcmFiaWxpdGllcyBzZWN0aW9uIGlmIHRoZXJlIGFyZSBhbnlcbiAgaWYgKHZ1bG5lcmFiaWxpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCB0YWJsZSBvciB1c2UgZGVmYXVsdCB2YWx1ZVxuICAgIGNvbnN0IGN1cnJlbnRZID0gKGRvYyBhcyBhbnkpLnByZXZpb3VzQXV0b1RhYmxlID8oZG9jIGFzIGFueSkucHJldmlvdXNBdXRvVGFibGUuZmluYWxZICsgMTUgOiAxNTA7XG4gICAgXG4gICAgZG9jLnNldEZvbnRTaXplKDE2KTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDUxLCAxMDIpOyAvLyBEYXJrIGJsdWUgY29sb3JcbiAgICBkb2MudGV4dCgnVnVsbmVyYWJpbGl0aWVzJywgMTQsIGN1cnJlbnRZKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0YWJsZSBmb3IgdnVsbmVyYWJpbGl0aWVzXG4gICAgY29uc3QgdGFibGVSb3dzID0gdnVsbmVyYWJpbGl0aWVzLm1hcCh2dWxuID0+IFtcbiAgICAgIHZ1bG4ubmFtZSxcbiAgICAgIHZ1bG4uc2V2ZXJpdHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2dWxuLnNldmVyaXR5LnNsaWNlKDEpLFxuICAgICAgdnVsbi5sb2NhdGlvbixcbiAgICAgIHZ1bG4uZGVzY3JpcHRpb24ubGVuZ3RoID4gNTAgPyB2dWxuLmRlc2NyaXB0aW9uLnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyA6IHZ1bG4uZGVzY3JpcHRpb25cbiAgICBdKTtcbiAgICBcbiAgICBhdXRvVGFibGUoZG9jLCB7XG4gICAgICBzdGFydFk6IGN1cnJlbnRZICsgMTAsXG4gICAgICBoZWFkOiBbWydOYW1lJywgJ1NldmVyaXR5JywgJ0xvY2F0aW9uJywgJ0Rlc2NyaXB0aW9uJ11dLFxuICAgICAgYm9keTogdGFibGVSb3dzLFxuICAgICAgdGhlbWU6ICdzdHJpcGVkJyxcbiAgICAgIGhlYWRTdHlsZXM6IHsgZmlsbENvbG9yOiBbMCwgNTEsIDEwMl0gfSxcbiAgICAgIGNvbHVtblN0eWxlczoge1xuICAgICAgICAwOiB7IGNlbGxXaWR0aDogNDAgfSxcbiAgICAgICAgMTogeyBjZWxsV2lkdGg6IDMwIH0sXG4gICAgICAgIDI6IHsgY2VsbFdpZHRoOiA0MCB9LFxuICAgICAgICAzOiB7IGNlbGxXaWR0aDogJ2F1dG8nIH1cbiAgICAgIH0sXG4gICAgICBkaWREcmF3UGFnZTogKGRhdGEpID0+IHtcbiAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyIGF0IHRoZSBib3R0b21cbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IGRvYy5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgICAgIGRvYy50ZXh0KGBQYWdlICR7cGFnZU51bWJlcn1gLCBwYWdlV2lkdGggLSAyMCwgZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpIC0gMTApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEFkZCBkZXRhaWxlZCB2dWxuZXJhYmlsaXR5IGluZm9ybWF0aW9uXG4gICAgdnVsbmVyYWJpbGl0aWVzLmZvckVhY2goKHZ1bG4sIGluZGV4KSA9PiB7XG4gICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgXG4gICAgICAvLyBBZGQgcGFnZSBudW1iZXJcbiAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICAgIGRvYy50ZXh0KGBQYWdlICR7cGFnZU51bWJlcn1gLCBwYWdlV2lkdGggLSAyMCwgZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpIC0gMTApO1xuICAgICAgXG4gICAgICAvLyBBZGQgdnVsbmVyYWJpbGl0eSBkZXRhaWxzXG4gICAgICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICAgICAgZG9jLnNldFRleHRDb2xvcigwLCA1MSwgMTAyKTsgLy8gRGFyayBibHVlIGNvbG9yXG4gICAgICBkb2MudGV4dChgVnVsbmVyYWJpbGl0eSAjJHtpbmRleCArIDF9OiAke3Z1bG4ubmFtZX1gLCAxNCwgMjApO1xuICAgICAgXG4gICAgICBkb2Muc2V0Rm9udFNpemUoMTIpO1xuICAgICAgZG9jLnNldFRleHRDb2xvcigwLCAwLCAwKTsgLy8gQmxhY2sgY29sb3JcbiAgICAgIGRvYy50ZXh0KGBTZXZlcml0eTogJHt2dWxuLnNldmVyaXR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdnVsbi5zZXZlcml0eS5zbGljZSgxKX1gLCAxNCwgMzApO1xuICAgICAgZG9jLnRleHQoYExvY2F0aW9uOiAke3Z1bG4ubG9jYXRpb259YCwgMTQsIDM3KTtcbiAgICAgIFxuICAgICAgaWYgKHZ1bG4uY3dlX2lkKSB7XG4gICAgICAgIGRvYy50ZXh0KGBDV0UgSUQ6ICR7dnVsbi5jd2VfaWR9YCwgMTQsIDQ0KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHZ1bG4uY3Zzc19zY29yZSkge1xuICAgICAgICBkb2MudGV4dChgQ1ZTUyBTY29yZTogJHt2dWxuLmN2c3Nfc2NvcmV9YCwgMTQsIDUxKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVzY3JpcHRpb24gd2l0aCB3b3JkIHdyYXBcbiAgICAgIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gICAgICBkb2MudGV4dCgnRGVzY3JpcHRpb246JywgMTQsIDU4KTtcbiAgICAgIGNvbnN0IHNwbGl0RGVzY3JpcHRpb24gPSBkb2Muc3BsaXRUZXh0VG9TaXplKHZ1bG4uZGVzY3JpcHRpb24sIHBhZ2VXaWR0aCAtIDI4KTtcbiAgICAgIGRvYy50ZXh0KHNwbGl0RGVzY3JpcHRpb24sIDE0LCA2NSk7XG4gICAgICBcbiAgICAgIGxldCBjdXJyZW50WVBvc2l0aW9uID0gNjUgKyAoc3BsaXREZXNjcmlwdGlvbi5sZW5ndGggKiA3KTtcbiAgICAgIFxuICAgICAgLy8gRXZpZGVuY2Ugd2l0aCB3b3JkIHdyYXAgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodnVsbi5ldmlkZW5jZSkge1xuICAgICAgICBkb2MudGV4dCgnRXZpZGVuY2U6JywgMTQsIGN1cnJlbnRZUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBzcGxpdEV2aWRlbmNlID0gZG9jLnNwbGl0VGV4dFRvU2l6ZSh2dWxuLmV2aWRlbmNlLCBwYWdlV2lkdGggLSAyOCk7XG4gICAgICAgIGRvYy50ZXh0KHNwbGl0RXZpZGVuY2UsIDE0LCBjdXJyZW50WVBvc2l0aW9uICsgNyk7XG4gICAgICAgIGN1cnJlbnRZUG9zaXRpb24gKz0gNyArIChzcGxpdEV2aWRlbmNlLmxlbmd0aCAqIDcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbmhhbmNlZCByZW1lZGlhdGlvbiBzZWN0aW9uIHdpdGggc3RydWN0dXJlZCBmb3JtYXRcbiAgICAgIGlmICh2dWxuLnJlbWVkaWF0aW9uKSB7XG4gICAgICAgIC8vIE1haW4gcmVtZWRpYXRpb24gaGVhZGluZ1xuICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTQpO1xuICAgICAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDUxLCAxMDIpOyAvLyBEYXJrIGJsdWUgY29sb3JcbiAgICAgICAgZG9jLnRleHQoJ1JlbWVkaWF0aW9uOicsIDE0LCBjdXJyZW50WVBvc2l0aW9uKTtcbiAgICAgICAgY3VycmVudFlQb3NpdGlvbiArPSAxMDtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IHRvIG5vcm1hbCB0ZXh0IHN0eWxlXG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7IC8vIEJsYWNrIGNvbG9yXG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSB0aGUgcmVtZWRpYXRpb24gdGV4dCB0byBpZGVudGlmeSBzZWN0aW9ucyBhbmQgY2xlYW4gbWFya2Rvd24gZm9ybWF0dGluZ1xuICAgICAgICBsZXQgcmVtZWRpYXRpb25UZXh0ID0gdnVsbi5yZW1lZGlhdGlvbjtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBtYXJrZG93biBoZWFkZXIgZm9ybWF0dGluZyAoIyMjIGFuZCAjIyMjKVxuICAgICAgICByZW1lZGlhdGlvblRleHQgPSByZW1lZGlhdGlvblRleHQucmVwbGFjZSgvXiMjI1xccysvZ20sICcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1lZGlhdGlvbiB0ZXh0IGNvbnRhaW5zIHN0cnVjdHVyZWQgc2VjdGlvbnNcbiAgICAgICAgaWYgKHJlbWVkaWF0aW9uVGV4dC5pbmNsdWRlcygnMS4gSW1wb3J0YW5jZSBvZiBGaXhpbmcnKSB8fCByZW1lZGlhdGlvblRleHQuaW5jbHVkZXMoJyMjIyMgMS4gSW1wb3J0YW5jZSBvZiBGaXhpbmcnKSkge1xuICAgICAgICAgIC8vIEZvciBzdHJ1Y3R1cmVkIHJlbWVkaWF0aW9uIGZvcm1hdCAtIHJlbW92ZSBtYXJrZG93biBoZWFkZXJzIGFuZCBjbGVhbiB1cCBmb3JtYXR0aW5nXG4gICAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIGFueSByZW1haW5pbmcgbWFya2Rvd24gaGVhZGVyc1xuICAgICAgICAgIHJlbWVkaWF0aW9uVGV4dCA9IHJlbWVkaWF0aW9uVGV4dC5yZXBsYWNlKC8jIyMjXFxzKy9nbSwgJycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNwbGl0IGJ5IHNlY3Rpb24gbnVtYmVycyAoMS4sIDIuLCBldGMuKVxuICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gcmVtZWRpYXRpb25UZXh0LnNwbGl0KC9cXGQrXFwuXFxzKy8pO1xuICAgICAgICAgIFxuICAgICAgICAgIGxldCBjdXJyZW50U2VjdGlvbiA9ICcnO1xuICAgICAgICAgIGxldCBzZWN0aW9uWSA9IGN1cnJlbnRZUG9zaXRpb247XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHNlY3Rpb24gYWZ0ZXIgdGhlIHNwbGl0IChza2lwIHRoZSBmaXJzdCBlbXB0eSBlbGVtZW50IGlmIGV4aXN0cylcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbnNbaV0udHJpbSgpID09PSAnJykgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2VjdGlvbiB0aXRsZSBhbmQgY29udGVudFxuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBhcnRzID0gc2VjdGlvbnNbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyBtYXJrZG93biBmb3JtYXR0aW5nIGZyb20gc2VjdGlvbiB0aXRsZVxuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblRpdGxlID0gc2VjdGlvblBhcnRzWzBdLnRyaW0oKS5yZXBsYWNlKC9eIytcXHMqL2csICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25Db250ZW50ID0gc2VjdGlvblBhcnRzLnNsaWNlKDEpLmpvaW4oJ1xcbicpLnRyaW0oKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHNlY3Rpb24gdGl0bGUgd2l0aCBib2xkIHN0eWxpbmdcbiAgICAgICAgICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnYm9sZCcpO1xuICAgICAgICAgICAgZG9jLnRleHQoc2VjdGlvblRpdGxlLCAxNCwgc2VjdGlvblkpO1xuICAgICAgICAgICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICAgICAgICAgIHNlY3Rpb25ZICs9IDc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBzZWN0aW9uIGNvbnRlbnQgd2l0aCBwcm9wZXIgZm9ybWF0dGluZ1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRDb250ZW50ID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShzZWN0aW9uQ29udGVudCwgcGFnZVdpZHRoIC0gMjgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ldyBwYWdlXG4gICAgICAgICAgICBpZiAoc2VjdGlvblkgKyAoc3BsaXRDb250ZW50Lmxlbmd0aCAqIDcpID4gZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpIC0gMjApIHtcbiAgICAgICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgICAgICAgc2VjdGlvblkgPSAyMDtcbiAgICAgICAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgICAgICAgICAgICBkb2MudGV4dChgUGFnZSAke3BhZ2VOdW1iZXJ9YCwgcGFnZVdpZHRoIC0gMjAsIGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRIZWlnaHQoKSAtIDEwKTtcbiAgICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIGNvZGUgZXhhbXBsZXMgd2l0aCBzcGVjaWFsIGZvcm1hdHRpbmdcbiAgICAgICAgICAgIGlmIChzZWN0aW9uQ29udGVudC5pbmNsdWRlcygnYGBgJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudFBhcnRzID0gc2VjdGlvbkNvbnRlbnQuc3BsaXQoL2BgYFxcdypcXG4vKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRlbnRZID0gc2VjdGlvblk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRlbnRQYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gUmVndWxhciB0ZXh0XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWd1bGFyVGV4dCA9IGNvbnRlbnRQYXJ0c1tqXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVndWxhclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRSZWd1bGFyID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShyZWd1bGFyVGV4dCwgcGFnZVdpZHRoIC0gMjgpO1xuICAgICAgICAgICAgICAgICAgICBkb2MudGV4dChzcGxpdFJlZ3VsYXIsIDE0LCBjb250ZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRZICs9IHNwbGl0UmVndWxhci5sZW5ndGggKiA3O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBDb2RlIGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVUZXh0ID0gY29udGVudFBhcnRzW2pdLnNwbGl0KCdgYGAnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyBhIGxpZ2h0IGdyYXkgYmFja2dyb3VuZCBmb3IgY29kZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc2V0RmlsbENvbG9yKDI0MCwgMjQwLCAyNDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdENvZGUgPSBkb2Muc3BsaXRUZXh0VG9TaXplKGNvZGVUZXh0LCBwYWdlV2lkdGggLSA0MCk7XG4gICAgICAgICAgICAgICAgICAgIGRvYy5yZWN0KDE0LCBjb250ZW50WSAtIDUsIHBhZ2VXaWR0aCAtIDI4LCBzcGxpdENvZGUubGVuZ3RoICogNyArIDEwLCAnRicpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb2RlIHdpdGggbW9ub3NwYWNlIGZvbnRcbiAgICAgICAgICAgICAgICAgICAgZG9jLnNldEZvbnQoJ2NvdXJpZXInLCAnbm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgICAgIGRvYy50ZXh0KHNwbGl0Q29kZSwgMjAsIGNvbnRlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFkgKz0gc3BsaXRDb2RlLmxlbmd0aCAqIDcgKyAxMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VjdGlvblkgPSBjb250ZW50WSArIDEwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVndWxhciB0ZXh0IHdpdGhvdXQgY29kZSBleGFtcGxlc1xuICAgICAgICAgICAgICBkb2MudGV4dChzcGxpdENvbnRlbnQsIDE0LCBzZWN0aW9uWSk7XG4gICAgICAgICAgICAgIHNlY3Rpb25ZICs9IHNwbGl0Q29udGVudC5sZW5ndGggKiA3ICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gPSBzZWN0aW9uWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb3Igc2ltcGxlIHVuc3RydWN0dXJlZCByZW1lZGlhdGlvbiB0ZXh0XG4gICAgICAgICAgLy8gQ2xlYW4gdXAgYW55IG1hcmtkb3duIGZvcm1hdHRpbmcgZnJvbSB1bnN0cnVjdHVyZWQgdGV4dFxuICAgICAgICAgIHJlbWVkaWF0aW9uVGV4dCA9IHJlbWVkaWF0aW9uVGV4dC5yZXBsYWNlKC9eIyMjXFxzKy9nbSwgJycpO1xuICAgICAgICAgIHJlbWVkaWF0aW9uVGV4dCA9IHJlbWVkaWF0aW9uVGV4dC5yZXBsYWNlKC9eIyMjI1xccysvZ20sICcnKTtcbiAgICAgICAgICByZW1lZGlhdGlvblRleHQgPSByZW1lZGlhdGlvblRleHQucmVwbGFjZSgvXiNcXHMrL2dtLCAnJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3Qgc3BsaXRSZW1lZGlhdGlvbiA9IGRvYy5zcGxpdFRleHRUb1NpemUocmVtZWRpYXRpb25UZXh0LCBwYWdlV2lkdGggLSAyOCk7XG4gICAgICAgICAgZG9jLnRleHQoc3BsaXRSZW1lZGlhdGlvbiwgMTQsIGN1cnJlbnRZUG9zaXRpb24pO1xuICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gKz0gc3BsaXRSZW1lZGlhdGlvbi5sZW5ndGggKiA3O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEFkZCBmb290ZXIgd2l0aCBnZW5lcmF0aW9uIGRhdGVcbiAgY29uc3QgcGFnZUNvdW50ID0gZG9jLmdldE51bWJlck9mUGFnZXMoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcGFnZUNvdW50OyBpKyspIHtcbiAgICBkb2Muc2V0UGFnZShpKTtcbiAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMTAwLCAxMDAsIDEwMCk7IC8vIEdyYXkgY29sb3JcbiAgICBkb2MudGV4dChgUmVwb3J0IGdlbmVyYXRlZCBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKX1gLCAxNCwgZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpIC0gMTApO1xuICB9XG4gIFxuICAvLyBSZXR1cm4gdGhlIFBERiBhcyBhIGJsb2JcbiAgcmV0dXJuIGRvYy5vdXRwdXQoJ2Jsb2InKTtcbn07Il0sIm5hbWVzIjpbImpzUERGIiwiYXV0b1RhYmxlIiwiZ2VuZXJhdGVQREZSZXBvcnQiLCJzY2FuIiwidnVsbmVyYWJpbGl0aWVzIiwiZG9jIiwicGFnZVdpZHRoIiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImdldFdpZHRoIiwic2V0Rm9udFNpemUiLCJzZXRUZXh0Q29sb3IiLCJ0ZXh0IiwiYWxpZ24iLCJ1cmwiLCJ0YXJnZXQiLCJzY2FuX3R5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsInN0YXJ0VGltZVZhbHVlIiwic3RhcnRfdGltZSIsInN0YXJ0ZWRfYXQiLCJlbmRUaW1lVmFsdWUiLCJlbmRfdGltZSIsImNvbXBsZXRlZF9hdCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJnZXRUaW1lIiwidG9GaXhlZCIsInN1bW1hcnkiLCJ0b3RhbF92dWxuZXJhYmlsaXRpZXMiLCJzZXZlcml0eV9jb3VudHMiLCJzZXZlcml0eUNvdW50cyIsInN0YXJ0WSIsImhlYWQiLCJib2R5IiwiY3JpdGljYWwiLCJ0b1N0cmluZyIsImhpZ2giLCJtZWRpdW0iLCJsb3ciLCJpbmZvIiwidGhlbWUiLCJoZWFkU3R5bGVzIiwiZmlsbENvbG9yIiwiY29sdW1uU3R5bGVzIiwiY2VsbFdpZHRoIiwiaGFsaWduIiwibGVuZ3RoIiwiY3VycmVudFkiLCJwcmV2aW91c0F1dG9UYWJsZSIsImZpbmFsWSIsInRhYmxlUm93cyIsIm1hcCIsInZ1bG4iLCJuYW1lIiwic2V2ZXJpdHkiLCJsb2NhdGlvbiIsImRlc2NyaXB0aW9uIiwic3Vic3RyaW5nIiwiZGlkRHJhd1BhZ2UiLCJkYXRhIiwicGFnZU51bWJlciIsImdldE51bWJlck9mUGFnZXMiLCJnZXRIZWlnaHQiLCJmb3JFYWNoIiwiaW5kZXgiLCJhZGRQYWdlIiwiY3dlX2lkIiwiY3Zzc19zY29yZSIsInNwbGl0RGVzY3JpcHRpb24iLCJzcGxpdFRleHRUb1NpemUiLCJjdXJyZW50WVBvc2l0aW9uIiwiZXZpZGVuY2UiLCJzcGxpdEV2aWRlbmNlIiwicmVtZWRpYXRpb24iLCJyZW1lZGlhdGlvblRleHQiLCJyZXBsYWNlIiwiaW5jbHVkZXMiLCJzZWN0aW9ucyIsInNwbGl0IiwiY3VycmVudFNlY3Rpb24iLCJzZWN0aW9uWSIsImkiLCJ0cmltIiwic2VjdGlvblBhcnRzIiwic2VjdGlvblRpdGxlIiwic2VjdGlvbkNvbnRlbnQiLCJqb2luIiwic2V0Rm9udCIsInNwbGl0Q29udGVudCIsImNvbnRlbnRQYXJ0cyIsImNvbnRlbnRZIiwiaiIsInJlZ3VsYXJUZXh0Iiwic3BsaXRSZWd1bGFyIiwiY29kZVRleHQiLCJzZXRGaWxsQ29sb3IiLCJzcGxpdENvZGUiLCJyZWN0Iiwic3BsaXRSZW1lZGlhdGlvbiIsInBhZ2VDb3VudCIsInNldFBhZ2UiLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/pdfGenerator.ts\n"));

/***/ })

});