"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_utils_pdfGenerator_ts",{

/***/ "./src/utils/pdfGenerator.ts":
/*!***********************************!*\
  !*** ./src/utils/pdfGenerator.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generatePDFReport: function() { return /* binding */ generatePDFReport; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n\n\n/**\n * Generate a PDF report from scan data\n * @param scan The scan details\n * @param vulnerabilities List of vulnerabilities found in the scan\n * @returns Blob containing the PDF document\n */ const generatePDFReport = function(scan) {\n    let vulnerabilities = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    // Initialize PDF document\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__.jsPDF();\n    const pageWidth = doc.internal.pageSize.getWidth();\n    // Add report title\n    doc.setFontSize(20);\n    doc.setTextColor(0, 51, 102); // Dark blue color\n    doc.text(\"Website Security Scan Report\", pageWidth / 2, 20, {\n        align: \"center\"\n    });\n    // Add scan information\n    doc.setFontSize(12);\n    doc.setTextColor(0, 0, 0); // Black color\n    doc.text(\"URL: \".concat(scan.url || scan.target || \"N/A\"), 14, 35);\n    doc.text(\"Scan Type: \".concat(scan.scan_type ? scan.scan_type.charAt(0).toUpperCase() + scan.scan_type.slice(1) : \"N/A\"), 14, 42);\n    doc.text(\"Status: \".concat(scan.status.charAt(0).toUpperCase() + scan.status.slice(1)), 14, 49);\n    doc.text(\"Date: \".concat(scan.created_at ? new Date(scan.created_at).toLocaleString() : \"N/A\"), 14, 56);\n    // Handle different time field names\n    const startTimeValue = scan.start_time || scan.started_at;\n    const endTimeValue = scan.end_time || scan.completed_at;\n    if (startTimeValue && endTimeValue) {\n        const startTime = new Date(startTimeValue);\n        const endTime = new Date(endTimeValue);\n        doc.text(\"Duration: \".concat(((endTime.getTime() - startTime.getTime()) / 1000 / 60).toFixed(2), \" minutes\"), 14, 63);\n    }\n    // Add summary section\n    doc.setFontSize(16);\n    doc.setTextColor(0, 51, 102); // Dark blue color\n    doc.text(\"Summary\", 14, 75);\n    if (scan.summary) {\n        doc.setFontSize(12);\n        doc.setTextColor(0, 0, 0); // Black color\n        doc.text(\"Total Vulnerabilities: \".concat(scan.summary.total_vulnerabilities), 14, 85);\n        // Add severity counts\n        if (scan.summary.severity_counts) {\n            const severityCounts = scan.summary.severity_counts;\n            // Create a table for severity counts\n            (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n                startY: 95,\n                head: [\n                    [\n                        \"Severity\",\n                        \"Count\"\n                    ]\n                ],\n                body: [\n                    [\n                        \"Critical\",\n                        severityCounts.critical.toString()\n                    ],\n                    [\n                        \"High\",\n                        severityCounts.high.toString()\n                    ],\n                    [\n                        \"Medium\",\n                        severityCounts.medium.toString()\n                    ],\n                    [\n                        \"Low\",\n                        severityCounts.low.toString()\n                    ],\n                    [\n                        \"Info\",\n                        severityCounts.info.toString()\n                    ]\n                ],\n                theme: \"striped\",\n                headStyles: {\n                    fillColor: [\n                        0,\n                        51,\n                        102\n                    ]\n                },\n                columnStyles: {\n                    0: {\n                        cellWidth: 40\n                    },\n                    1: {\n                        cellWidth: 40,\n                        halign: \"center\"\n                    }\n                }\n            });\n        }\n    }\n    // Add vulnerabilities section if there are any\n    if (vulnerabilities.length > 0) {\n        // Get the position after the last table or use default value\n        const currentY = doc.previousAutoTable ? doc.previousAutoTable.finalY + 15 : 150;\n        doc.setFontSize(16);\n        doc.setTextColor(0, 51, 102); // Dark blue color\n        doc.text(\"Vulnerabilities\", 14, currentY);\n        // Create a table for vulnerabilities\n        const tableRows = vulnerabilities.map((vuln)=>[\n                vuln.name,\n                vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1),\n                vuln.location,\n                vuln.description.length > 50 ? vuln.description.substring(0, 50) + \"...\" : vuln.description\n            ]);\n        (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n            startY: currentY + 10,\n            head: [\n                [\n                    \"Name\",\n                    \"Severity\",\n                    \"Location\",\n                    \"Description\"\n                ]\n            ],\n            body: tableRows,\n            theme: \"striped\",\n            headStyles: {\n                fillColor: [\n                    0,\n                    51,\n                    102\n                ]\n            },\n            columnStyles: {\n                0: {\n                    cellWidth: 40\n                },\n                1: {\n                    cellWidth: 30\n                },\n                2: {\n                    cellWidth: 40\n                },\n                3: {\n                    cellWidth: \"auto\"\n                }\n            },\n            didDrawPage: (data)=>{\n                // Add page number at the bottom\n                const pageNumber = doc.getNumberOfPages();\n                doc.setFontSize(10);\n                doc.text(\"Page \".concat(pageNumber), pageWidth - 20, doc.internal.pageSize.getHeight() - 10);\n            }\n        });\n        // Add detailed vulnerability information\n        vulnerabilities.forEach((vuln, index)=>{\n            doc.addPage();\n            // Add page number\n            const pageNumber = doc.getNumberOfPages();\n            doc.setFontSize(10);\n            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, doc.internal.pageSize.getHeight() - 10);\n            // Add vulnerability details\n            doc.setFontSize(16);\n            doc.setTextColor(0, 51, 102); // Dark blue color\n            doc.text(\"Vulnerability #\".concat(index + 1, \": \").concat(vuln.name), 14, 20);\n            doc.setFontSize(12);\n            doc.setTextColor(0, 0, 0); // Black color\n            doc.text(\"Severity: \".concat(vuln.severity.charAt(0).toUpperCase() + vuln.severity.slice(1)), 14, 30);\n            doc.text(\"Location: \".concat(vuln.location), 14, 37);\n            if (vuln.cwe_id) {\n                doc.text(\"CWE ID: \".concat(vuln.cwe_id), 14, 44);\n            }\n            if (vuln.cvss_score) {\n                doc.text(\"CVSS Score: \".concat(vuln.cvss_score), 14, 51);\n            }\n            // Description with word wrap\n            doc.setFontSize(12);\n            doc.text(\"Description:\", 14, 58);\n            const splitDescription = doc.splitTextToSize(vuln.description, pageWidth - 28);\n            doc.text(splitDescription, 14, 65);\n            let currentYPosition = 65 + splitDescription.length * 7;\n            // Evidence with word wrap if available\n            if (vuln.evidence) {\n                doc.text(\"Evidence:\", 14, currentYPosition);\n                const splitEvidence = doc.splitTextToSize(vuln.evidence, pageWidth - 28);\n                doc.text(splitEvidence, 14, currentYPosition + 7);\n                currentYPosition += 7 + splitEvidence.length * 7;\n            }\n            // Enhanced remediation section with structured format\n            if (vuln.remediation) {\n                // Check if we need to add a new page for remediation section\n                const pageHeight = doc.internal.pageSize.getHeight();\n                if (currentYPosition > pageHeight - 60) {\n                    doc.addPage();\n                    // Add page number\n                    const pageNumber = doc.getNumberOfPages();\n                    doc.setFontSize(10);\n                    doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                    currentYPosition = 20; // Reset position to top of new page\n                }\n                // Main remediation heading\n                doc.setFontSize(14);\n                doc.setTextColor(0, 51, 102); // Dark blue color\n                doc.text(\"Remediation:\", 14, currentYPosition);\n                currentYPosition += 10;\n                // Reset to normal text style\n                doc.setFontSize(12);\n                doc.setTextColor(0, 0, 0); // Black color\n                // Parse the remediation text to identify sections and clean markdown formatting\n                let remediationText = vuln.remediation;\n                // Remove all markdown header formatting (# through ####)\n                remediationText = remediationText.replace(/^#{1,4}\\s+/gm, \"\");\n                // Check if the remediation text contains structured sections\n                if (remediationText.includes(\"1. Importance of Fixing\") || remediationText.includes(\"Importance of Fixing\")) {\n                    // For structured remediation format - remove markdown headers and clean up formatting\n                    // Split by section numbers (1., 2., etc.)\n                    const sections = remediationText.split(/\\d+\\.\\s+/);\n                    // If the split didn't work well (only one section), try another approach\n                    if (sections.length <= 1) {\n                        // Try splitting by newline followed by a number and period\n                        const altSections = remediationText.split(/\\n\\d+\\.\\s+/);\n                        if (altSections.length > 1) {\n                            // Use this split instead\n                            sections.length = 0; // Clear the array\n                            altSections.forEach((section)=>sections.push(section));\n                        }\n                    }\n                    let sectionY = currentYPosition;\n                    const marginBottom = 20; // Space to reserve at bottom of page\n                    // Process each section after the split (skip the first empty element if exists)\n                    for(let i = 0; i < sections.length; i++){\n                        if (sections[i].trim() === \"\") continue;\n                        // Extract section title and content\n                        const sectionParts = sections[i].split(\"\\n\");\n                        // Clean up any remaining markdown formatting from section title\n                        const sectionTitle = sectionParts[0].trim().replace(/^#+\\s*/g, \"\");\n                        const sectionContent = sectionParts.slice(1).join(\"\\n\").trim();\n                        // Check if we need to add a new page before starting a new section\n                        if (sectionY > pageHeight - 40) {\n                            doc.addPage();\n                            // Add page number\n                            const pageNumber = doc.getNumberOfPages();\n                            doc.setFontSize(10);\n                            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                            sectionY = 20; // Reset position to top of new page\n                        }\n                        // Add section title with bold styling\n                        doc.setFont(\"helvetica\", \"bold\");\n                        doc.text(sectionTitle, 14, sectionY);\n                        doc.setFont(\"helvetica\", \"normal\");\n                        sectionY += 7;\n                        // Add section content with proper formatting\n                        const splitContent = doc.splitTextToSize(sectionContent, pageWidth - 28);\n                        // Check if content will fit on current page\n                        const contentHeight = splitContent.length * 7;\n                        if (sectionY + contentHeight > pageHeight - marginBottom) {\n                            // Content won't fit on current page\n                            // Calculate how many lines will fit on current page\n                            const availableHeight = pageHeight - marginBottom - sectionY;\n                            const linesPerPage = Math.floor(availableHeight / 7);\n                            if (linesPerPage > 0) {\n                                // Add as many lines as will fit on current page\n                                const firstPageLines = splitContent.slice(0, linesPerPage);\n                                doc.text(firstPageLines, 14, sectionY);\n                            }\n                            // Add a new page for remaining content\n                            doc.addPage();\n                            // Add page number\n                            const pageNumber = doc.getNumberOfPages();\n                            doc.setFontSize(10);\n                            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                            doc.setFontSize(12);\n                            // Continue with remaining content on new page\n                            const remainingLines = splitContent.slice(linesPerPage > 0 ? linesPerPage : 0);\n                            if (remainingLines.length > 0) {\n                                sectionY = 20; // Reset position to top of new page\n                                doc.text(remainingLines, 14, sectionY);\n                                sectionY += remainingLines.length * 7 + 10;\n                            } else {\n                                sectionY = 20; // Reset position to top of new page\n                            }\n                        } else {\n                            // Content fits on current page\n                            doc.text(splitContent, 14, sectionY);\n                            sectionY += contentHeight + 10;\n                        }\n                        // Handle code examples with special formatting\n                        if (sectionContent.includes(\"```\")) {\n                            const contentParts = sectionContent.split(/```\\w*\\n/);\n                            let contentY = sectionY;\n                            for(let j = 0; j < contentParts.length; j++){\n                                if (j % 2 === 0) {\n                                    // Regular text\n                                    const regularText = contentParts[j].trim();\n                                    if (regularText) {\n                                        const splitRegular = doc.splitTextToSize(regularText, pageWidth - 28);\n                                        // Check if content will fit on current page\n                                        if (contentY + splitRegular.length * 7 > pageHeight - marginBottom) {\n                                            // Add a new page\n                                            doc.addPage();\n                                            // Add page number\n                                            const pageNumber = doc.getNumberOfPages();\n                                            doc.setFontSize(10);\n                                            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                                            doc.setFontSize(12);\n                                            contentY = 20; // Reset position to top of new page\n                                        }\n                                        doc.text(splitRegular, 14, contentY);\n                                        contentY += splitRegular.length * 7;\n                                    }\n                                } else {\n                                    // Code example\n                                    const codeText = contentParts[j].split(\"```\")[0].trim();\n                                    if (codeText) {\n                                        const splitCode = doc.splitTextToSize(codeText, pageWidth - 40);\n                                        const codeHeight = splitCode.length * 7 + 10;\n                                        // Check if code block will fit on current page\n                                        if (contentY + codeHeight > pageHeight - marginBottom) {\n                                            // Add a new page\n                                            doc.addPage();\n                                            // Add page number\n                                            const pageNumber = doc.getNumberOfPages();\n                                            doc.setFontSize(10);\n                                            doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                                            doc.setFontSize(12);\n                                            contentY = 20; // Reset position to top of new page\n                                        }\n                                        // Draw a light gray background for code\n                                        doc.setFillColor(240, 240, 240);\n                                        doc.rect(14, contentY - 5, pageWidth - 28, codeHeight, \"F\");\n                                        // Add the code with monospace font\n                                        doc.setFont(\"courier\", \"normal\");\n                                        doc.text(splitCode, 20, contentY);\n                                        doc.setFont(\"helvetica\", \"normal\");\n                                        contentY += codeHeight;\n                                    }\n                                }\n                            }\n                            sectionY = contentY + 10;\n                        }\n                    }\n                    currentYPosition = sectionY;\n                } else {\n                    // For simple unstructured remediation text\n                    // Clean up any markdown formatting from unstructured text\n                    remediationText = remediationText.replace(/^###\\s+/gm, \"\");\n                    remediationText = remediationText.replace(/^####\\s+/gm, \"\");\n                    remediationText = remediationText.replace(/^#\\s+/gm, \"\");\n                    const splitRemediation = doc.splitTextToSize(remediationText, pageWidth - 28);\n                    const remediationHeight = splitRemediation.length * 7;\n                    // Check if remediation text will fit on current page\n                    if (currentYPosition + remediationHeight > pageHeight - 20) {\n                        // Calculate how many lines will fit on current page\n                        const availableHeight = pageHeight - 20 - currentYPosition;\n                        const linesPerPage = Math.floor(availableHeight / 7);\n                        if (linesPerPage > 0) {\n                            // Add as many lines as will fit on current page\n                            const firstPageLines = splitRemediation.slice(0, linesPerPage);\n                            doc.text(firstPageLines, 14, currentYPosition);\n                        }\n                        // Add a new page for remaining content\n                        doc.addPage();\n                        // Add page number\n                        const pageNumber = doc.getNumberOfPages();\n                        doc.setFontSize(10);\n                        doc.text(\"Page \".concat(pageNumber), pageWidth - 20, pageHeight - 10);\n                        doc.setFontSize(12);\n                        // Continue with remaining content on new page\n                        const remainingLines = splitRemediation.slice(linesPerPage > 0 ? linesPerPage : 0);\n                        if (remainingLines.length > 0) {\n                            currentYPosition = 20; // Reset position to top of new page\n                            doc.text(remainingLines, 14, currentYPosition);\n                            currentYPosition += remainingLines.length * 7;\n                        } else {\n                            currentYPosition = 20; // Reset position to top of new page\n                        }\n                    } else {\n                        // Content fits on current page\n                        doc.text(splitRemediation, 14, currentYPosition);\n                        currentYPosition += remediationHeight;\n                    }\n                }\n            }\n        });\n    }\n    // Add footer with generation date\n    const pageCount = doc.getNumberOfPages();\n    for(let i = 1; i <= pageCount; i++){\n        doc.setPage(i);\n        doc.setFontSize(10);\n        doc.setTextColor(100, 100, 100); // Gray color\n        doc.text(\"Report generated on \".concat(new Date().toLocaleString()), 14, doc.internal.pageSize.getHeight() - 10);\n    }\n    // Return the PDF as a blob\n    return doc.output(\"blob\");\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvcGRmR2VuZXJhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QjtBQUNVO0FBMkN4Qzs7Ozs7Q0FLQyxHQUNNLE1BQU1FLG9CQUFvQixTQUFDQztRQUFtQkMsbUZBQW1DLEVBQUU7SUFDeEYsMEJBQTBCO0lBQzFCLE1BQU1DLE1BQU0sSUFBSUwsd0NBQUtBO0lBQ3JCLE1BQU1NLFlBQVlELElBQUlFLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxRQUFRO0lBRWhELG1CQUFtQjtJQUNuQkosSUFBSUssV0FBVyxDQUFDO0lBQ2hCTCxJQUFJTSxZQUFZLENBQUMsR0FBRyxJQUFJLE1BQU0sa0JBQWtCO0lBQ2hETixJQUFJTyxJQUFJLENBQUMsZ0NBQWdDTixZQUFZLEdBQUcsSUFBSTtRQUFFTyxPQUFPO0lBQVM7SUFFOUUsdUJBQXVCO0lBQ3ZCUixJQUFJSyxXQUFXLENBQUM7SUFDaEJMLElBQUlNLFlBQVksQ0FBQyxHQUFHLEdBQUcsSUFBSSxjQUFjO0lBQ3pDTixJQUFJTyxJQUFJLENBQUMsUUFBeUMsT0FBakNULEtBQUtXLEdBQUcsSUFBSVgsS0FBS1ksTUFBTSxJQUFJLFFBQVMsSUFBSTtJQUN6RFYsSUFBSU8sSUFBSSxDQUFDLGNBQXdHLE9BQTFGVCxLQUFLYSxTQUFTLEdBQUdiLEtBQUthLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS2YsS0FBS2EsU0FBUyxDQUFDRyxLQUFLLENBQUMsS0FBSyxRQUFTLElBQUk7SUFDeEhkLElBQUlPLElBQUksQ0FBQyxXQUFzRSxPQUEzRFQsS0FBS2lCLE1BQU0sQ0FBQ0gsTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS2YsS0FBS2lCLE1BQU0sQ0FBQ0QsS0FBSyxDQUFDLEtBQU0sSUFBSTtJQUN0RmQsSUFBSU8sSUFBSSxDQUFDLFNBQThFLE9BQXJFVCxLQUFLa0IsVUFBVSxHQUFHLElBQUlDLEtBQUtuQixLQUFLa0IsVUFBVSxFQUFFRSxjQUFjLEtBQUssUUFBUyxJQUFJO0lBRTlGLG9DQUFvQztJQUNwQyxNQUFNQyxpQkFBaUJyQixLQUFLc0IsVUFBVSxJQUFJdEIsS0FBS3VCLFVBQVU7SUFDekQsTUFBTUMsZUFBZXhCLEtBQUt5QixRQUFRLElBQUl6QixLQUFLMEIsWUFBWTtJQUV2RCxJQUFJTCxrQkFBa0JHLGNBQWM7UUFDbEMsTUFBTUcsWUFBWSxJQUFJUixLQUFLRTtRQUMzQixNQUFNTyxVQUFVLElBQUlULEtBQUtLO1FBQ3pCdEIsSUFBSU8sSUFBSSxDQUFDLGFBQWdGLE9BQW5FLENBQUMsQ0FBQ21CLFFBQVFDLE9BQU8sS0FBS0YsVUFBVUUsT0FBTyxFQUFDLElBQUssT0FBTyxFQUFDLEVBQUdDLE9BQU8sQ0FBQyxJQUFHLGFBQVcsSUFBSTtJQUMxRztJQUVBLHNCQUFzQjtJQUN0QjVCLElBQUlLLFdBQVcsQ0FBQztJQUNoQkwsSUFBSU0sWUFBWSxDQUFDLEdBQUcsSUFBSSxNQUFNLGtCQUFrQjtJQUNoRE4sSUFBSU8sSUFBSSxDQUFDLFdBQVcsSUFBSTtJQUV4QixJQUFJVCxLQUFLK0IsT0FBTyxFQUFFO1FBQ2hCN0IsSUFBSUssV0FBVyxDQUFDO1FBQ2hCTCxJQUFJTSxZQUFZLENBQUMsR0FBRyxHQUFHLElBQUksY0FBYztRQUN6Q04sSUFBSU8sSUFBSSxDQUFDLDBCQUE2RCxPQUFuQ1QsS0FBSytCLE9BQU8sQ0FBQ0MscUJBQXFCLEdBQUksSUFBSTtRQUU3RSxzQkFBc0I7UUFDdEIsSUFBSWhDLEtBQUsrQixPQUFPLENBQUNFLGVBQWUsRUFBRTtZQUNoQyxNQUFNQyxpQkFBaUJsQyxLQUFLK0IsT0FBTyxDQUFDRSxlQUFlO1lBRW5ELHFDQUFxQztZQUNyQ25DLDJEQUFTQSxDQUFDSSxLQUFLO2dCQUNiaUMsUUFBUTtnQkFDUkMsTUFBTTtvQkFBQzt3QkFBQzt3QkFBWTtxQkFBUTtpQkFBQztnQkFDN0JDLE1BQU07b0JBQ0o7d0JBQUM7d0JBQVlILGVBQWVJLFFBQVEsQ0FBQ0MsUUFBUTtxQkFBRztvQkFDaEQ7d0JBQUM7d0JBQVFMLGVBQWVNLElBQUksQ0FBQ0QsUUFBUTtxQkFBRztvQkFDeEM7d0JBQUM7d0JBQVVMLGVBQWVPLE1BQU0sQ0FBQ0YsUUFBUTtxQkFBRztvQkFDNUM7d0JBQUM7d0JBQU9MLGVBQWVRLEdBQUcsQ0FBQ0gsUUFBUTtxQkFBRztvQkFDdEM7d0JBQUM7d0JBQVFMLGVBQWVTLElBQUksQ0FBQ0osUUFBUTtxQkFBRztpQkFDekM7Z0JBQ0RLLE9BQU87Z0JBQ1BDLFlBQVk7b0JBQUVDLFdBQVc7d0JBQUM7d0JBQUc7d0JBQUk7cUJBQUk7Z0JBQUM7Z0JBQ3RDQyxjQUFjO29CQUNaLEdBQUc7d0JBQUVDLFdBQVc7b0JBQUc7b0JBQ25CLEdBQUc7d0JBQUVBLFdBQVc7d0JBQUlDLFFBQVE7b0JBQVM7Z0JBQ3ZDO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsK0NBQStDO0lBQy9DLElBQUloRCxnQkFBZ0JpRCxNQUFNLEdBQUcsR0FBRztRQUM5Qiw2REFBNkQ7UUFDN0QsTUFBTUMsV0FBVyxJQUFhQyxpQkFBaUIsR0FBRSxJQUFhQSxpQkFBaUIsQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFFOUZuRCxJQUFJSyxXQUFXLENBQUM7UUFDaEJMLElBQUlNLFlBQVksQ0FBQyxHQUFHLElBQUksTUFBTSxrQkFBa0I7UUFDaEROLElBQUlPLElBQUksQ0FBQyxtQkFBbUIsSUFBSTBDO1FBRWhDLHFDQUFxQztRQUNyQyxNQUFNRyxZQUFZckQsZ0JBQWdCc0QsR0FBRyxDQUFDQyxDQUFBQSxPQUFRO2dCQUM1Q0EsS0FBS0MsSUFBSTtnQkFDVEQsS0FBS0UsUUFBUSxDQUFDNUMsTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS3lDLEtBQUtFLFFBQVEsQ0FBQzFDLEtBQUssQ0FBQztnQkFDNUR3QyxLQUFLRyxRQUFRO2dCQUNiSCxLQUFLSSxXQUFXLENBQUNWLE1BQU0sR0FBRyxLQUFLTSxLQUFLSSxXQUFXLENBQUNDLFNBQVMsQ0FBQyxHQUFHLE1BQU0sUUFBUUwsS0FBS0ksV0FBVzthQUM1RjtRQUVEOUQsMkRBQVNBLENBQUNJLEtBQUs7WUFDYmlDLFFBQVFnQixXQUFXO1lBQ25CZixNQUFNO2dCQUFDO29CQUFDO29CQUFRO29CQUFZO29CQUFZO2lCQUFjO2FBQUM7WUFDdkRDLE1BQU1pQjtZQUNOVixPQUFPO1lBQ1BDLFlBQVk7Z0JBQUVDLFdBQVc7b0JBQUM7b0JBQUc7b0JBQUk7aUJBQUk7WUFBQztZQUN0Q0MsY0FBYztnQkFDWixHQUFHO29CQUFFQyxXQUFXO2dCQUFHO2dCQUNuQixHQUFHO29CQUFFQSxXQUFXO2dCQUFHO2dCQUNuQixHQUFHO29CQUFFQSxXQUFXO2dCQUFHO2dCQUNuQixHQUFHO29CQUFFQSxXQUFXO2dCQUFPO1lBQ3pCO1lBQ0FjLGFBQWEsQ0FBQ0M7Z0JBQ1osZ0NBQWdDO2dCQUNoQyxNQUFNQyxhQUFhOUQsSUFBSStELGdCQUFnQjtnQkFDdkMvRCxJQUFJSyxXQUFXLENBQUM7Z0JBQ2hCTCxJQUFJTyxJQUFJLENBQUMsUUFBbUIsT0FBWHVELGFBQWM3RCxZQUFZLElBQUlELElBQUlFLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDNkQsU0FBUyxLQUFLO1lBQ3JGO1FBQ0Y7UUFFQSx5Q0FBeUM7UUFDekNqRSxnQkFBZ0JrRSxPQUFPLENBQUMsQ0FBQ1gsTUFBTVk7WUFDN0JsRSxJQUFJbUUsT0FBTztZQUVYLGtCQUFrQjtZQUNsQixNQUFNTCxhQUFhOUQsSUFBSStELGdCQUFnQjtZQUN2Qy9ELElBQUlLLFdBQVcsQ0FBQztZQUNoQkwsSUFBSU8sSUFBSSxDQUFDLFFBQW1CLE9BQVh1RCxhQUFjN0QsWUFBWSxJQUFJRCxJQUFJRSxRQUFRLENBQUNDLFFBQVEsQ0FBQzZELFNBQVMsS0FBSztZQUVuRiw0QkFBNEI7WUFDNUJoRSxJQUFJSyxXQUFXLENBQUM7WUFDaEJMLElBQUlNLFlBQVksQ0FBQyxHQUFHLElBQUksTUFBTSxrQkFBa0I7WUFDaEROLElBQUlPLElBQUksQ0FBQyxrQkFBZ0MrQyxPQUFkWSxRQUFRLEdBQUUsTUFBYyxPQUFWWixLQUFLQyxJQUFJLEdBQUksSUFBSTtZQUUxRHZELElBQUlLLFdBQVcsQ0FBQztZQUNoQkwsSUFBSU0sWUFBWSxDQUFDLEdBQUcsR0FBRyxJQUFJLGNBQWM7WUFDekNOLElBQUlPLElBQUksQ0FBQyxhQUE0RSxPQUEvRCtDLEtBQUtFLFFBQVEsQ0FBQzVDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUt5QyxLQUFLRSxRQUFRLENBQUMxQyxLQUFLLENBQUMsS0FBTSxJQUFJO1lBQzVGZCxJQUFJTyxJQUFJLENBQUMsYUFBMkIsT0FBZCtDLEtBQUtHLFFBQVEsR0FBSSxJQUFJO1lBRTNDLElBQUlILEtBQUtjLE1BQU0sRUFBRTtnQkFDZnBFLElBQUlPLElBQUksQ0FBQyxXQUF1QixPQUFaK0MsS0FBS2MsTUFBTSxHQUFJLElBQUk7WUFDekM7WUFFQSxJQUFJZCxLQUFLZSxVQUFVLEVBQUU7Z0JBQ25CckUsSUFBSU8sSUFBSSxDQUFDLGVBQStCLE9BQWhCK0MsS0FBS2UsVUFBVSxHQUFJLElBQUk7WUFDakQ7WUFFQSw2QkFBNkI7WUFDN0JyRSxJQUFJSyxXQUFXLENBQUM7WUFDaEJMLElBQUlPLElBQUksQ0FBQyxnQkFBZ0IsSUFBSTtZQUM3QixNQUFNK0QsbUJBQW1CdEUsSUFBSXVFLGVBQWUsQ0FBQ2pCLEtBQUtJLFdBQVcsRUFBRXpELFlBQVk7WUFDM0VELElBQUlPLElBQUksQ0FBQytELGtCQUFrQixJQUFJO1lBRS9CLElBQUlFLG1CQUFtQixLQUFNRixpQkFBaUJ0QixNQUFNLEdBQUc7WUFFdkQsdUNBQXVDO1lBQ3ZDLElBQUlNLEtBQUttQixRQUFRLEVBQUU7Z0JBQ2pCekUsSUFBSU8sSUFBSSxDQUFDLGFBQWEsSUFBSWlFO2dCQUMxQixNQUFNRSxnQkFBZ0IxRSxJQUFJdUUsZUFBZSxDQUFDakIsS0FBS21CLFFBQVEsRUFBRXhFLFlBQVk7Z0JBQ3JFRCxJQUFJTyxJQUFJLENBQUNtRSxlQUFlLElBQUlGLG1CQUFtQjtnQkFDL0NBLG9CQUFvQixJQUFLRSxjQUFjMUIsTUFBTSxHQUFHO1lBQ2xEO1lBRUEsc0RBQXNEO1lBQ3RELElBQUlNLEtBQUtxQixXQUFXLEVBQUU7Z0JBQ3BCLDZEQUE2RDtnQkFDN0QsTUFBTUMsYUFBYTVFLElBQUlFLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDNkQsU0FBUztnQkFDbEQsSUFBSVEsbUJBQW1CSSxhQUFhLElBQUk7b0JBQ3RDNUUsSUFBSW1FLE9BQU87b0JBQ1gsa0JBQWtCO29CQUNsQixNQUFNTCxhQUFhOUQsSUFBSStELGdCQUFnQjtvQkFDdkMvRCxJQUFJSyxXQUFXLENBQUM7b0JBQ2hCTCxJQUFJTyxJQUFJLENBQUMsUUFBbUIsT0FBWHVELGFBQWM3RCxZQUFZLElBQUkyRSxhQUFhO29CQUM1REosbUJBQW1CLElBQUksb0NBQW9DO2dCQUM3RDtnQkFFQSwyQkFBMkI7Z0JBQzNCeEUsSUFBSUssV0FBVyxDQUFDO2dCQUNoQkwsSUFBSU0sWUFBWSxDQUFDLEdBQUcsSUFBSSxNQUFNLGtCQUFrQjtnQkFDaEROLElBQUlPLElBQUksQ0FBQyxnQkFBZ0IsSUFBSWlFO2dCQUM3QkEsb0JBQW9CO2dCQUVwQiw2QkFBNkI7Z0JBQzdCeEUsSUFBSUssV0FBVyxDQUFDO2dCQUNoQkwsSUFBSU0sWUFBWSxDQUFDLEdBQUcsR0FBRyxJQUFJLGNBQWM7Z0JBRXpDLGdGQUFnRjtnQkFDaEYsSUFBSXVFLGtCQUFrQnZCLEtBQUtxQixXQUFXO2dCQUV0Qyx5REFBeUQ7Z0JBQ3pERSxrQkFBa0JBLGdCQUFnQkMsT0FBTyxDQUFDLGdCQUFnQjtnQkFFMUQsNkRBQTZEO2dCQUM3RCxJQUFJRCxnQkFBZ0JFLFFBQVEsQ0FBQyw4QkFBOEJGLGdCQUFnQkUsUUFBUSxDQUFDLHlCQUF5QjtvQkFDM0csc0ZBQXNGO29CQUV0RiwwQ0FBMEM7b0JBQzFDLE1BQU1DLFdBQVdILGdCQUFnQkksS0FBSyxDQUFDO29CQUV2Qyx5RUFBeUU7b0JBQ3pFLElBQUlELFNBQVNoQyxNQUFNLElBQUksR0FBRzt3QkFDeEIsMkRBQTJEO3dCQUMzRCxNQUFNa0MsY0FBY0wsZ0JBQWdCSSxLQUFLLENBQUM7d0JBQzFDLElBQUlDLFlBQVlsQyxNQUFNLEdBQUcsR0FBRzs0QkFDMUIseUJBQXlCOzRCQUN6QmdDLFNBQVNoQyxNQUFNLEdBQUcsR0FBRyxrQkFBa0I7NEJBQ3ZDa0MsWUFBWWpCLE9BQU8sQ0FBQ2tCLENBQUFBLFVBQVdILFNBQVNJLElBQUksQ0FBQ0Q7d0JBQy9DO29CQUNGO29CQUVBLElBQUlFLFdBQVdiO29CQUNmLE1BQU1jLGVBQWUsSUFBSSxxQ0FBcUM7b0JBRTlELGdGQUFnRjtvQkFDaEYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLFNBQVNoQyxNQUFNLEVBQUV1QyxJQUFLO3dCQUN4QyxJQUFJUCxRQUFRLENBQUNPLEVBQUUsQ0FBQ0MsSUFBSSxPQUFPLElBQUk7d0JBRS9CLG9DQUFvQzt3QkFDcEMsTUFBTUMsZUFBZVQsUUFBUSxDQUFDTyxFQUFFLENBQUNOLEtBQUssQ0FBQzt3QkFDdkMsZ0VBQWdFO3dCQUNoRSxNQUFNUyxlQUFlRCxZQUFZLENBQUMsRUFBRSxDQUFDRCxJQUFJLEdBQUdWLE9BQU8sQ0FBQyxXQUFXO3dCQUMvRCxNQUFNYSxpQkFBaUJGLGFBQWEzRSxLQUFLLENBQUMsR0FBRzhFLElBQUksQ0FBQyxNQUFNSixJQUFJO3dCQUU1RCxtRUFBbUU7d0JBQ25FLElBQUlILFdBQVdULGFBQWEsSUFBSTs0QkFDOUI1RSxJQUFJbUUsT0FBTzs0QkFDWCxrQkFBa0I7NEJBQ2xCLE1BQU1MLGFBQWE5RCxJQUFJK0QsZ0JBQWdCOzRCQUN2Qy9ELElBQUlLLFdBQVcsQ0FBQzs0QkFDaEJMLElBQUlPLElBQUksQ0FBQyxRQUFtQixPQUFYdUQsYUFBYzdELFlBQVksSUFBSTJFLGFBQWE7NEJBQzVEUyxXQUFXLElBQUksb0NBQW9DO3dCQUNyRDt3QkFFQSxzQ0FBc0M7d0JBQ3RDckYsSUFBSTZGLE9BQU8sQ0FBQyxhQUFhO3dCQUN6QjdGLElBQUlPLElBQUksQ0FBQ21GLGNBQWMsSUFBSUw7d0JBQzNCckYsSUFBSTZGLE9BQU8sQ0FBQyxhQUFhO3dCQUN6QlIsWUFBWTt3QkFFWiw2Q0FBNkM7d0JBQzdDLE1BQU1TLGVBQWU5RixJQUFJdUUsZUFBZSxDQUFDb0IsZ0JBQWdCMUYsWUFBWTt3QkFFckUsNENBQTRDO3dCQUM1QyxNQUFNOEYsZ0JBQWdCRCxhQUFhOUMsTUFBTSxHQUFHO3dCQUM1QyxJQUFJcUMsV0FBV1UsZ0JBQWdCbkIsYUFBYVUsY0FBYzs0QkFDeEQsb0NBQW9DOzRCQUNwQyxvREFBb0Q7NEJBQ3BELE1BQU1VLGtCQUFrQnBCLGFBQWFVLGVBQWVEOzRCQUNwRCxNQUFNWSxlQUFlQyxLQUFLQyxLQUFLLENBQUNILGtCQUFrQjs0QkFFbEQsSUFBSUMsZUFBZSxHQUFHO2dDQUNwQixnREFBZ0Q7Z0NBQ2hELE1BQU1HLGlCQUFpQk4sYUFBYWhGLEtBQUssQ0FBQyxHQUFHbUY7Z0NBQzdDakcsSUFBSU8sSUFBSSxDQUFDNkYsZ0JBQWdCLElBQUlmOzRCQUMvQjs0QkFFQSx1Q0FBdUM7NEJBQ3ZDckYsSUFBSW1FLE9BQU87NEJBQ1gsa0JBQWtCOzRCQUNsQixNQUFNTCxhQUFhOUQsSUFBSStELGdCQUFnQjs0QkFDdkMvRCxJQUFJSyxXQUFXLENBQUM7NEJBQ2hCTCxJQUFJTyxJQUFJLENBQUMsUUFBbUIsT0FBWHVELGFBQWM3RCxZQUFZLElBQUkyRSxhQUFhOzRCQUM1RDVFLElBQUlLLFdBQVcsQ0FBQzs0QkFFaEIsOENBQThDOzRCQUM5QyxNQUFNZ0csaUJBQWlCUCxhQUFhaEYsS0FBSyxDQUFDbUYsZUFBZSxJQUFJQSxlQUFlOzRCQUM1RSxJQUFJSSxlQUFlckQsTUFBTSxHQUFHLEdBQUc7Z0NBQzdCcUMsV0FBVyxJQUFJLG9DQUFvQztnQ0FDbkRyRixJQUFJTyxJQUFJLENBQUM4RixnQkFBZ0IsSUFBSWhCO2dDQUM3QkEsWUFBWWdCLGVBQWVyRCxNQUFNLEdBQUcsSUFBSTs0QkFDMUMsT0FBTztnQ0FDTHFDLFdBQVcsSUFBSSxvQ0FBb0M7NEJBQ3JEO3dCQUNGLE9BQU87NEJBQ0wsK0JBQStCOzRCQUMvQnJGLElBQUlPLElBQUksQ0FBQ3VGLGNBQWMsSUFBSVQ7NEJBQzNCQSxZQUFZVSxnQkFBZ0I7d0JBQzlCO3dCQUVBLCtDQUErQzt3QkFDL0MsSUFBSUosZUFBZVosUUFBUSxDQUFDLFFBQVE7NEJBQ2xDLE1BQU11QixlQUFlWCxlQUFlVixLQUFLLENBQUM7NEJBQzFDLElBQUlzQixXQUFXbEI7NEJBRWYsSUFBSyxJQUFJbUIsSUFBSSxHQUFHQSxJQUFJRixhQUFhdEQsTUFBTSxFQUFFd0QsSUFBSztnQ0FDNUMsSUFBSUEsSUFBSSxNQUFNLEdBQUc7b0NBQ2YsZUFBZTtvQ0FDZixNQUFNQyxjQUFjSCxZQUFZLENBQUNFLEVBQUUsQ0FBQ2hCLElBQUk7b0NBQ3hDLElBQUlpQixhQUFhO3dDQUNmLE1BQU1DLGVBQWUxRyxJQUFJdUUsZUFBZSxDQUFDa0MsYUFBYXhHLFlBQVk7d0NBRWxFLDRDQUE0Qzt3Q0FDNUMsSUFBSXNHLFdBQVlHLGFBQWExRCxNQUFNLEdBQUcsSUFBSzRCLGFBQWFVLGNBQWM7NENBQ3BFLGlCQUFpQjs0Q0FDakJ0RixJQUFJbUUsT0FBTzs0Q0FDWCxrQkFBa0I7NENBQ2xCLE1BQU1MLGFBQWE5RCxJQUFJK0QsZ0JBQWdCOzRDQUN2Qy9ELElBQUlLLFdBQVcsQ0FBQzs0Q0FDaEJMLElBQUlPLElBQUksQ0FBQyxRQUFtQixPQUFYdUQsYUFBYzdELFlBQVksSUFBSTJFLGFBQWE7NENBQzVENUUsSUFBSUssV0FBVyxDQUFDOzRDQUNoQmtHLFdBQVcsSUFBSSxvQ0FBb0M7d0NBQ3JEO3dDQUVBdkcsSUFBSU8sSUFBSSxDQUFDbUcsY0FBYyxJQUFJSDt3Q0FDM0JBLFlBQVlHLGFBQWExRCxNQUFNLEdBQUc7b0NBQ3BDO2dDQUNGLE9BQU87b0NBQ0wsZUFBZTtvQ0FDZixNQUFNMkQsV0FBV0wsWUFBWSxDQUFDRSxFQUFFLENBQUN2QixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQ08sSUFBSTtvQ0FDckQsSUFBSW1CLFVBQVU7d0NBQ1osTUFBTUMsWUFBWTVHLElBQUl1RSxlQUFlLENBQUNvQyxVQUFVMUcsWUFBWTt3Q0FDNUQsTUFBTTRHLGFBQWFELFVBQVU1RCxNQUFNLEdBQUcsSUFBSTt3Q0FFMUMsK0NBQStDO3dDQUMvQyxJQUFJdUQsV0FBV00sYUFBYWpDLGFBQWFVLGNBQWM7NENBQ3JELGlCQUFpQjs0Q0FDakJ0RixJQUFJbUUsT0FBTzs0Q0FDWCxrQkFBa0I7NENBQ2xCLE1BQU1MLGFBQWE5RCxJQUFJK0QsZ0JBQWdCOzRDQUN2Qy9ELElBQUlLLFdBQVcsQ0FBQzs0Q0FDaEJMLElBQUlPLElBQUksQ0FBQyxRQUFtQixPQUFYdUQsYUFBYzdELFlBQVksSUFBSTJFLGFBQWE7NENBQzVENUUsSUFBSUssV0FBVyxDQUFDOzRDQUNoQmtHLFdBQVcsSUFBSSxvQ0FBb0M7d0NBQ3JEO3dDQUVBLHdDQUF3Qzt3Q0FDeEN2RyxJQUFJOEcsWUFBWSxDQUFDLEtBQUssS0FBSzt3Q0FDM0I5RyxJQUFJK0csSUFBSSxDQUFDLElBQUlSLFdBQVcsR0FBR3RHLFlBQVksSUFBSTRHLFlBQVk7d0NBRXZELG1DQUFtQzt3Q0FDbkM3RyxJQUFJNkYsT0FBTyxDQUFDLFdBQVc7d0NBQ3ZCN0YsSUFBSU8sSUFBSSxDQUFDcUcsV0FBVyxJQUFJTDt3Q0FDeEJ2RyxJQUFJNkYsT0FBTyxDQUFDLGFBQWE7d0NBQ3pCVSxZQUFZTTtvQ0FDZDtnQ0FDRjs0QkFDRjs0QkFDQXhCLFdBQVdrQixXQUFXO3dCQUN4QjtvQkFDRjtvQkFFQS9CLG1CQUFtQmE7Z0JBQ3JCLE9BQU87b0JBQ0wsMkNBQTJDO29CQUMzQywwREFBMEQ7b0JBQzFEUixrQkFBa0JBLGdCQUFnQkMsT0FBTyxDQUFDLGFBQWE7b0JBQ3ZERCxrQkFBa0JBLGdCQUFnQkMsT0FBTyxDQUFDLGNBQWM7b0JBQ3hERCxrQkFBa0JBLGdCQUFnQkMsT0FBTyxDQUFDLFdBQVc7b0JBRXJELE1BQU1rQyxtQkFBbUJoSCxJQUFJdUUsZUFBZSxDQUFDTSxpQkFBaUI1RSxZQUFZO29CQUMxRSxNQUFNZ0gsb0JBQW9CRCxpQkFBaUJoRSxNQUFNLEdBQUc7b0JBRXBELHFEQUFxRDtvQkFDckQsSUFBSXdCLG1CQUFtQnlDLG9CQUFvQnJDLGFBQWEsSUFBSTt3QkFDMUQsb0RBQW9EO3dCQUNwRCxNQUFNb0Isa0JBQWtCcEIsYUFBYSxLQUFLSjt3QkFDMUMsTUFBTXlCLGVBQWVDLEtBQUtDLEtBQUssQ0FBQ0gsa0JBQWtCO3dCQUVsRCxJQUFJQyxlQUFlLEdBQUc7NEJBQ3BCLGdEQUFnRDs0QkFDaEQsTUFBTUcsaUJBQWlCWSxpQkFBaUJsRyxLQUFLLENBQUMsR0FBR21GOzRCQUNqRGpHLElBQUlPLElBQUksQ0FBQzZGLGdCQUFnQixJQUFJNUI7d0JBQy9CO3dCQUVBLHVDQUF1Qzt3QkFDdkN4RSxJQUFJbUUsT0FBTzt3QkFDWCxrQkFBa0I7d0JBQ2xCLE1BQU1MLGFBQWE5RCxJQUFJK0QsZ0JBQWdCO3dCQUN2Qy9ELElBQUlLLFdBQVcsQ0FBQzt3QkFDaEJMLElBQUlPLElBQUksQ0FBQyxRQUFtQixPQUFYdUQsYUFBYzdELFlBQVksSUFBSTJFLGFBQWE7d0JBQzVENUUsSUFBSUssV0FBVyxDQUFDO3dCQUVoQiw4Q0FBOEM7d0JBQzlDLE1BQU1nRyxpQkFBaUJXLGlCQUFpQmxHLEtBQUssQ0FBQ21GLGVBQWUsSUFBSUEsZUFBZTt3QkFDaEYsSUFBSUksZUFBZXJELE1BQU0sR0FBRyxHQUFHOzRCQUM3QndCLG1CQUFtQixJQUFJLG9DQUFvQzs0QkFDM0R4RSxJQUFJTyxJQUFJLENBQUM4RixnQkFBZ0IsSUFBSTdCOzRCQUM3QkEsb0JBQW9CNkIsZUFBZXJELE1BQU0sR0FBRzt3QkFDOUMsT0FBTzs0QkFDTHdCLG1CQUFtQixJQUFJLG9DQUFvQzt3QkFDN0Q7b0JBQ0YsT0FBTzt3QkFDTCwrQkFBK0I7d0JBQy9CeEUsSUFBSU8sSUFBSSxDQUFDeUcsa0JBQWtCLElBQUl4Qzt3QkFDL0JBLG9CQUFvQnlDO29CQUN0QjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLGtDQUFrQztJQUNsQyxNQUFNQyxZQUFZbEgsSUFBSStELGdCQUFnQjtJQUN0QyxJQUFLLElBQUl3QixJQUFJLEdBQUdBLEtBQUsyQixXQUFXM0IsSUFBSztRQUNuQ3ZGLElBQUltSCxPQUFPLENBQUM1QjtRQUNadkYsSUFBSUssV0FBVyxDQUFDO1FBQ2hCTCxJQUFJTSxZQUFZLENBQUMsS0FBSyxLQUFLLE1BQU0sYUFBYTtRQUM5Q04sSUFBSU8sSUFBSSxDQUFDLHVCQUFtRCxPQUE1QixJQUFJVSxPQUFPQyxjQUFjLEtBQU0sSUFBSWxCLElBQUlFLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDNkQsU0FBUyxLQUFLO0lBQ3pHO0lBRUEsMkJBQTJCO0lBQzNCLE9BQU9oRSxJQUFJb0gsTUFBTSxDQUFDO0FBQ3BCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3BkZkdlbmVyYXRvci50cz9kYzFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzUERGIH0gZnJvbSAnanNwZGYnO1xuaW1wb3J0IGF1dG9UYWJsZSBmcm9tICdqc3BkZi1hdXRvdGFibGUnO1xuXG5pbnRlcmZhY2UgU2V2ZXJpdHlDb3VudHMge1xuICBjcml0aWNhbDogbnVtYmVyO1xuICBoaWdoOiBudW1iZXI7XG4gIG1lZGl1bTogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgaW5mbzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU2NhblN1bW1hcnkge1xuICB0b3RhbF92dWxuZXJhYmlsaXRpZXM6IG51bWJlcjtcbiAgc2V2ZXJpdHlfY291bnRzOiBTZXZlcml0eUNvdW50cztcbiAgc2Nhbl9kdXJhdGlvbj86IG51bWJlcjtcbiAgcGFnZXNfc2Nhbm5lZD86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFZ1bG5lcmFiaWxpdHkge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHNldmVyaXR5OiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIGV2aWRlbmNlPzogc3RyaW5nO1xuICByZW1lZGlhdGlvbj86IHN0cmluZztcbiAgY3dlX2lkPzogc3RyaW5nO1xuICBjdnNzX3Njb3JlPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU2NhbkRldGFpbHMge1xuICBpZDogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHRhcmdldD86IHN0cmluZzsgLy8gQWRkZWQgdGFyZ2V0IGZpZWxkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHVybFxuICBzY2FuX3R5cGU/OiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICBzdGFydGVkX2F0Pzogc3RyaW5nOyAvLyBBZGRlZCBzdGFydGVkX2F0IGZpZWxkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHN0YXJ0X3RpbWVcbiAgY29tcGxldGVkX2F0Pzogc3RyaW5nOyAvLyBBZGRlZCBjb21wbGV0ZWRfYXQgZmllbGQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gZW5kX3RpbWVcbiAgc3RhcnRfdGltZT86IHN0cmluZyB8IG51bGw7XG4gIGVuZF90aW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgc3VtbWFyeTogU2NhblN1bW1hcnkgfCBudWxsO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgUERGIHJlcG9ydCBmcm9tIHNjYW4gZGF0YVxuICogQHBhcmFtIHNjYW4gVGhlIHNjYW4gZGV0YWlsc1xuICogQHBhcmFtIHZ1bG5lcmFiaWxpdGllcyBMaXN0IG9mIHZ1bG5lcmFiaWxpdGllcyBmb3VuZCBpbiB0aGUgc2NhblxuICogQHJldHVybnMgQmxvYiBjb250YWluaW5nIHRoZSBQREYgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUERGUmVwb3J0ID0gKHNjYW46IFNjYW5EZXRhaWxzLCB2dWxuZXJhYmlsaXRpZXM6IFZ1bG5lcmFiaWxpdHlbXSA9IFtdKTogQmxvYiA9PiB7XG4gIC8vIEluaXRpYWxpemUgUERGIGRvY3VtZW50XG4gIGNvbnN0IGRvYyA9IG5ldyBqc1BERigpO1xuICBjb25zdCBwYWdlV2lkdGggPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcbiAgXG4gIC8vIEFkZCByZXBvcnQgdGl0bGVcbiAgZG9jLnNldEZvbnRTaXplKDIwKTtcbiAgZG9jLnNldFRleHRDb2xvcigwLCA1MSwgMTAyKTsgLy8gRGFyayBibHVlIGNvbG9yXG4gIGRvYy50ZXh0KCdXZWJzaXRlIFNlY3VyaXR5IFNjYW4gUmVwb3J0JywgcGFnZVdpZHRoIC8gMiwgMjAsIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuICBcbiAgLy8gQWRkIHNjYW4gaW5mb3JtYXRpb25cbiAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgZG9jLnNldFRleHRDb2xvcigwLCAwLCAwKTsgLy8gQmxhY2sgY29sb3JcbiAgZG9jLnRleHQoYFVSTDogJHtzY2FuLnVybCB8fCBzY2FuLnRhcmdldCB8fCAnTi9BJ31gLCAxNCwgMzUpO1xuICBkb2MudGV4dChgU2NhbiBUeXBlOiAke3NjYW4uc2Nhbl90eXBlID8gc2Nhbi5zY2FuX3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzY2FuLnNjYW5fdHlwZS5zbGljZSgxKSA6ICdOL0EnfWAsIDE0LCA0Mik7XG4gIGRvYy50ZXh0KGBTdGF0dXM6ICR7c2Nhbi5zdGF0dXMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzY2FuLnN0YXR1cy5zbGljZSgxKX1gLCAxNCwgNDkpO1xuICBkb2MudGV4dChgRGF0ZTogJHtzY2FuLmNyZWF0ZWRfYXQgPyBuZXcgRGF0ZShzY2FuLmNyZWF0ZWRfYXQpLnRvTG9jYWxlU3RyaW5nKCkgOiAnTi9BJ31gLCAxNCwgNTYpO1xuICBcbiAgLy8gSGFuZGxlIGRpZmZlcmVudCB0aW1lIGZpZWxkIG5hbWVzXG4gIGNvbnN0IHN0YXJ0VGltZVZhbHVlID0gc2Nhbi5zdGFydF90aW1lIHx8IHNjYW4uc3RhcnRlZF9hdDtcbiAgY29uc3QgZW5kVGltZVZhbHVlID0gc2Nhbi5lbmRfdGltZSB8fCBzY2FuLmNvbXBsZXRlZF9hdDtcbiAgXG4gIGlmIChzdGFydFRpbWVWYWx1ZSAmJiBlbmRUaW1lVmFsdWUpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWVWYWx1ZSk7XG4gICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKGVuZFRpbWVWYWx1ZSk7XG4gICAgZG9jLnRleHQoYER1cmF0aW9uOiAkeygoZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpKSAvIDEwMDAgLyA2MCkudG9GaXhlZCgyKX0gbWludXRlc2AsIDE0LCA2Myk7XG4gIH1cbiAgXG4gIC8vIEFkZCBzdW1tYXJ5IHNlY3Rpb25cbiAgZG9jLnNldEZvbnRTaXplKDE2KTtcbiAgZG9jLnNldFRleHRDb2xvcigwLCA1MSwgMTAyKTsgLy8gRGFyayBibHVlIGNvbG9yXG4gIGRvYy50ZXh0KCdTdW1tYXJ5JywgMTQsIDc1KTtcbiAgXG4gIGlmIChzY2FuLnN1bW1hcnkpIHtcbiAgICBkb2Muc2V0Rm9udFNpemUoMTIpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7IC8vIEJsYWNrIGNvbG9yXG4gICAgZG9jLnRleHQoYFRvdGFsIFZ1bG5lcmFiaWxpdGllczogJHtzY2FuLnN1bW1hcnkudG90YWxfdnVsbmVyYWJpbGl0aWVzfWAsIDE0LCA4NSk7XG4gICAgXG4gICAgLy8gQWRkIHNldmVyaXR5IGNvdW50c1xuICAgIGlmIChzY2FuLnN1bW1hcnkuc2V2ZXJpdHlfY291bnRzKSB7XG4gICAgICBjb25zdCBzZXZlcml0eUNvdW50cyA9IHNjYW4uc3VtbWFyeS5zZXZlcml0eV9jb3VudHM7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHRhYmxlIGZvciBzZXZlcml0eSBjb3VudHNcbiAgICAgIGF1dG9UYWJsZShkb2MsIHtcbiAgICAgICAgc3RhcnRZOiA5NSxcbiAgICAgICAgaGVhZDogW1snU2V2ZXJpdHknLCAnQ291bnQnXV0sXG4gICAgICAgIGJvZHk6IFtcbiAgICAgICAgICBbJ0NyaXRpY2FsJywgc2V2ZXJpdHlDb3VudHMuY3JpdGljYWwudG9TdHJpbmcoKV0sXG4gICAgICAgICAgWydIaWdoJywgc2V2ZXJpdHlDb3VudHMuaGlnaC50b1N0cmluZygpXSxcbiAgICAgICAgICBbJ01lZGl1bScsIHNldmVyaXR5Q291bnRzLm1lZGl1bS50b1N0cmluZygpXSxcbiAgICAgICAgICBbJ0xvdycsIHNldmVyaXR5Q291bnRzLmxvdy50b1N0cmluZygpXSxcbiAgICAgICAgICBbJ0luZm8nLCBzZXZlcml0eUNvdW50cy5pbmZvLnRvU3RyaW5nKCldXG4gICAgICAgIF0sXG4gICAgICAgIHRoZW1lOiAnc3RyaXBlZCcsXG4gICAgICAgIGhlYWRTdHlsZXM6IHsgZmlsbENvbG9yOiBbMCwgNTEsIDEwMl0gfSxcbiAgICAgICAgY29sdW1uU3R5bGVzOiB7XG4gICAgICAgICAgMDogeyBjZWxsV2lkdGg6IDQwIH0sXG4gICAgICAgICAgMTogeyBjZWxsV2lkdGg6IDQwLCBoYWxpZ246ICdjZW50ZXInIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBBZGQgdnVsbmVyYWJpbGl0aWVzIHNlY3Rpb24gaWYgdGhlcmUgYXJlIGFueVxuICBpZiAodnVsbmVyYWJpbGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IHRhYmxlIG9yIHVzZSBkZWZhdWx0IHZhbHVlXG4gICAgY29uc3QgY3VycmVudFkgPSAoZG9jIGFzIGFueSkucHJldmlvdXNBdXRvVGFibGUgPyhkb2MgYXMgYW55KS5wcmV2aW91c0F1dG9UYWJsZS5maW5hbFkgKyAxNSA6IDE1MDtcbiAgICBcbiAgICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgNTEsIDEwMik7IC8vIERhcmsgYmx1ZSBjb2xvclxuICAgIGRvYy50ZXh0KCdWdWxuZXJhYmlsaXRpZXMnLCAxNCwgY3VycmVudFkpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHRhYmxlIGZvciB2dWxuZXJhYmlsaXRpZXNcbiAgICBjb25zdCB0YWJsZVJvd3MgPSB2dWxuZXJhYmlsaXRpZXMubWFwKHZ1bG4gPT4gW1xuICAgICAgdnVsbi5uYW1lLFxuICAgICAgdnVsbi5zZXZlcml0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZ1bG4uc2V2ZXJpdHkuc2xpY2UoMSksXG4gICAgICB2dWxuLmxvY2F0aW9uLFxuICAgICAgdnVsbi5kZXNjcmlwdGlvbi5sZW5ndGggPiA1MCA/IHZ1bG4uZGVzY3JpcHRpb24uc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nIDogdnVsbi5kZXNjcmlwdGlvblxuICAgIF0pO1xuICAgIFxuICAgIGF1dG9UYWJsZShkb2MsIHtcbiAgICAgIHN0YXJ0WTogY3VycmVudFkgKyAxMCxcbiAgICAgIGhlYWQ6IFtbJ05hbWUnLCAnU2V2ZXJpdHknLCAnTG9jYXRpb24nLCAnRGVzY3JpcHRpb24nXV0sXG4gICAgICBib2R5OiB0YWJsZVJvd3MsXG4gICAgICB0aGVtZTogJ3N0cmlwZWQnLFxuICAgICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFswLCA1MSwgMTAyXSB9LFxuICAgICAgY29sdW1uU3R5bGVzOiB7XG4gICAgICAgIDA6IHsgY2VsbFdpZHRoOiA0MCB9LFxuICAgICAgICAxOiB7IGNlbGxXaWR0aDogMzAgfSxcbiAgICAgICAgMjogeyBjZWxsV2lkdGg6IDQwIH0sXG4gICAgICAgIDM6IHsgY2VsbFdpZHRoOiAnYXV0bycgfVxuICAgICAgfSxcbiAgICAgIGRpZERyYXdQYWdlOiAoZGF0YSkgPT4ge1xuICAgICAgICAvLyBBZGQgcGFnZSBudW1iZXIgYXQgdGhlIGJvdHRvbVxuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gZG9jLmdldE51bWJlck9mUGFnZXMoKTtcbiAgICAgICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICAgICAgZG9jLnRleHQoYFBhZ2UgJHtwYWdlTnVtYmVyfWAsIHBhZ2VXaWR0aCAtIDIwLCBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCkgLSAxMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIGRldGFpbGVkIHZ1bG5lcmFiaWxpdHkgaW5mb3JtYXRpb25cbiAgICB2dWxuZXJhYmlsaXRpZXMuZm9yRWFjaCgodnVsbiwgaW5kZXgpID0+IHtcbiAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBwYWdlIG51bWJlclxuICAgICAgY29uc3QgcGFnZU51bWJlciA9IGRvYy5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgICAgZG9jLnRleHQoYFBhZ2UgJHtwYWdlTnVtYmVyfWAsIHBhZ2VXaWR0aCAtIDIwLCBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCkgLSAxMCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCB2dWxuZXJhYmlsaXR5IGRldGFpbHNcbiAgICAgIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gICAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDUxLCAxMDIpOyAvLyBEYXJrIGJsdWUgY29sb3JcbiAgICAgIGRvYy50ZXh0KGBWdWxuZXJhYmlsaXR5ICMke2luZGV4ICsgMX06ICR7dnVsbi5uYW1lfWAsIDE0LCAyMCk7XG4gICAgICBcbiAgICAgIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gICAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApOyAvLyBCbGFjayBjb2xvclxuICAgICAgZG9jLnRleHQoYFNldmVyaXR5OiAke3Z1bG4uc2V2ZXJpdHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2dWxuLnNldmVyaXR5LnNsaWNlKDEpfWAsIDE0LCAzMCk7XG4gICAgICBkb2MudGV4dChgTG9jYXRpb246ICR7dnVsbi5sb2NhdGlvbn1gLCAxNCwgMzcpO1xuICAgICAgXG4gICAgICBpZiAodnVsbi5jd2VfaWQpIHtcbiAgICAgICAgZG9jLnRleHQoYENXRSBJRDogJHt2dWxuLmN3ZV9pZH1gLCAxNCwgNDQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodnVsbi5jdnNzX3Njb3JlKSB7XG4gICAgICAgIGRvYy50ZXh0KGBDVlNTIFNjb3JlOiAke3Z1bG4uY3Zzc19zY29yZX1gLCAxNCwgNTEpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXNjcmlwdGlvbiB3aXRoIHdvcmQgd3JhcFxuICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgIGRvYy50ZXh0KCdEZXNjcmlwdGlvbjonLCAxNCwgNTgpO1xuICAgICAgY29uc3Qgc3BsaXREZXNjcmlwdGlvbiA9IGRvYy5zcGxpdFRleHRUb1NpemUodnVsbi5kZXNjcmlwdGlvbiwgcGFnZVdpZHRoIC0gMjgpO1xuICAgICAgZG9jLnRleHQoc3BsaXREZXNjcmlwdGlvbiwgMTQsIDY1KTtcbiAgICAgIFxuICAgICAgbGV0IGN1cnJlbnRZUG9zaXRpb24gPSA2NSArIChzcGxpdERlc2NyaXB0aW9uLmxlbmd0aCAqIDcpO1xuICAgICAgXG4gICAgICAvLyBFdmlkZW5jZSB3aXRoIHdvcmQgd3JhcCBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh2dWxuLmV2aWRlbmNlKSB7XG4gICAgICAgIGRvYy50ZXh0KCdFdmlkZW5jZTonLCAxNCwgY3VycmVudFlQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHNwbGl0RXZpZGVuY2UgPSBkb2Muc3BsaXRUZXh0VG9TaXplKHZ1bG4uZXZpZGVuY2UsIHBhZ2VXaWR0aCAtIDI4KTtcbiAgICAgICAgZG9jLnRleHQoc3BsaXRFdmlkZW5jZSwgMTQsIGN1cnJlbnRZUG9zaXRpb24gKyA3KTtcbiAgICAgICAgY3VycmVudFlQb3NpdGlvbiArPSA3ICsgKHNwbGl0RXZpZGVuY2UubGVuZ3RoICogNyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEVuaGFuY2VkIHJlbWVkaWF0aW9uIHNlY3Rpb24gd2l0aCBzdHJ1Y3R1cmVkIGZvcm1hdFxuICAgICAgaWYgKHZ1bG4ucmVtZWRpYXRpb24pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXcgcGFnZSBmb3IgcmVtZWRpYXRpb24gc2VjdGlvblxuICAgICAgICBjb25zdCBwYWdlSGVpZ2h0ID0gZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpO1xuICAgICAgICBpZiAoY3VycmVudFlQb3NpdGlvbiA+IHBhZ2VIZWlnaHQgLSA2MCkgeyAvLyBMZWF2ZSBlbm91Z2ggc3BhY2UgZm9yIGhlYWRpbmcgYW5kIGluaXRpYWwgY29udGVudFxuICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IGRvYy5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICAgICAgICBkb2MudGV4dChgUGFnZSAke3BhZ2VOdW1iZXJ9YCwgcGFnZVdpZHRoIC0gMjAsIHBhZ2VIZWlnaHQgLSAxMCk7XG4gICAgICAgICAgY3VycmVudFlQb3NpdGlvbiA9IDIwOyAvLyBSZXNldCBwb3NpdGlvbiB0byB0b3Agb2YgbmV3IHBhZ2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFpbiByZW1lZGlhdGlvbiBoZWFkaW5nXG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxNCk7XG4gICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgNTEsIDEwMik7IC8vIERhcmsgYmx1ZSBjb2xvclxuICAgICAgICBkb2MudGV4dCgnUmVtZWRpYXRpb246JywgMTQsIGN1cnJlbnRZUG9zaXRpb24pO1xuICAgICAgICBjdXJyZW50WVBvc2l0aW9uICs9IDEwO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgdG8gbm9ybWFsIHRleHQgc3R5bGVcbiAgICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgICAgZG9jLnNldFRleHRDb2xvcigwLCAwLCAwKTsgLy8gQmxhY2sgY29sb3JcbiAgICAgICAgXG4gICAgICAgIC8vIFBhcnNlIHRoZSByZW1lZGlhdGlvbiB0ZXh0IHRvIGlkZW50aWZ5IHNlY3Rpb25zIGFuZCBjbGVhbiBtYXJrZG93biBmb3JtYXR0aW5nXG4gICAgICAgIGxldCByZW1lZGlhdGlvblRleHQgPSB2dWxuLnJlbWVkaWF0aW9uO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXJrZG93biBoZWFkZXIgZm9ybWF0dGluZyAoIyB0aHJvdWdoICMjIyMpXG4gICAgICAgIHJlbWVkaWF0aW9uVGV4dCA9IHJlbWVkaWF0aW9uVGV4dC5yZXBsYWNlKC9eI3sxLDR9XFxzKy9nbSwgJycpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbWVkaWF0aW9uIHRleHQgY29udGFpbnMgc3RydWN0dXJlZCBzZWN0aW9uc1xuICAgICAgICBpZiAocmVtZWRpYXRpb25UZXh0LmluY2x1ZGVzKCcxLiBJbXBvcnRhbmNlIG9mIEZpeGluZycpIHx8IHJlbWVkaWF0aW9uVGV4dC5pbmNsdWRlcygnSW1wb3J0YW5jZSBvZiBGaXhpbmcnKSkge1xuICAgICAgICAgIC8vIEZvciBzdHJ1Y3R1cmVkIHJlbWVkaWF0aW9uIGZvcm1hdCAtIHJlbW92ZSBtYXJrZG93biBoZWFkZXJzIGFuZCBjbGVhbiB1cCBmb3JtYXR0aW5nXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3BsaXQgYnkgc2VjdGlvbiBudW1iZXJzICgxLiwgMi4sIGV0Yy4pXG4gICAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSByZW1lZGlhdGlvblRleHQuc3BsaXQoL1xcZCtcXC5cXHMrLyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgdGhlIHNwbGl0IGRpZG4ndCB3b3JrIHdlbGwgKG9ubHkgb25lIHNlY3Rpb24pLCB0cnkgYW5vdGhlciBhcHByb2FjaFxuICAgICAgICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgLy8gVHJ5IHNwbGl0dGluZyBieSBuZXdsaW5lIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIGFuZCBwZXJpb2RcbiAgICAgICAgICAgIGNvbnN0IGFsdFNlY3Rpb25zID0gcmVtZWRpYXRpb25UZXh0LnNwbGl0KC9cXG5cXGQrXFwuXFxzKy8pO1xuICAgICAgICAgICAgaWYgKGFsdFNlY3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgc3BsaXQgaW5zdGVhZFxuICAgICAgICAgICAgICBzZWN0aW9ucy5sZW5ndGggPSAwOyAvLyBDbGVhciB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgYWx0U2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHNlY3Rpb25zLnB1c2goc2VjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgc2VjdGlvblkgPSBjdXJyZW50WVBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9IDIwOyAvLyBTcGFjZSB0byByZXNlcnZlIGF0IGJvdHRvbSBvZiBwYWdlXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHNlY3Rpb24gYWZ0ZXIgdGhlIHNwbGl0IChza2lwIHRoZSBmaXJzdCBlbXB0eSBlbGVtZW50IGlmIGV4aXN0cylcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbnNbaV0udHJpbSgpID09PSAnJykgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2VjdGlvbiB0aXRsZSBhbmQgY29udGVudFxuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBhcnRzID0gc2VjdGlvbnNbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyBtYXJrZG93biBmb3JtYXR0aW5nIGZyb20gc2VjdGlvbiB0aXRsZVxuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblRpdGxlID0gc2VjdGlvblBhcnRzWzBdLnRyaW0oKS5yZXBsYWNlKC9eIytcXHMqL2csICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25Db250ZW50ID0gc2VjdGlvblBhcnRzLnNsaWNlKDEpLmpvaW4oJ1xcbicpLnRyaW0oKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXcgcGFnZSBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgc2VjdGlvblxuICAgICAgICAgICAgaWYgKHNlY3Rpb25ZID4gcGFnZUhlaWdodCAtIDQwKSB7IC8vIExlYXZlIHNwYWNlIGZvciB0aXRsZSBhbmQgc29tZSBjb250ZW50XG4gICAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgICAgIC8vIEFkZCBwYWdlIG51bWJlclxuICAgICAgICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gZG9jLmdldE51bWJlck9mUGFnZXMoKTtcbiAgICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICAgICAgICAgICAgZG9jLnRleHQoYFBhZ2UgJHtwYWdlTnVtYmVyfWAsIHBhZ2VXaWR0aCAtIDIwLCBwYWdlSGVpZ2h0IC0gMTApO1xuICAgICAgICAgICAgICBzZWN0aW9uWSA9IDIwOyAvLyBSZXNldCBwb3NpdGlvbiB0byB0b3Agb2YgbmV3IHBhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHNlY3Rpb24gdGl0bGUgd2l0aCBib2xkIHN0eWxpbmdcbiAgICAgICAgICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnYm9sZCcpO1xuICAgICAgICAgICAgZG9jLnRleHQoc2VjdGlvblRpdGxlLCAxNCwgc2VjdGlvblkpO1xuICAgICAgICAgICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgICAgICAgICAgIHNlY3Rpb25ZICs9IDc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBzZWN0aW9uIGNvbnRlbnQgd2l0aCBwcm9wZXIgZm9ybWF0dGluZ1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRDb250ZW50ID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShzZWN0aW9uQ29udGVudCwgcGFnZVdpZHRoIC0gMjgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjb250ZW50IHdpbGwgZml0IG9uIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgY29uc3QgY29udGVudEhlaWdodCA9IHNwbGl0Q29udGVudC5sZW5ndGggKiA3O1xuICAgICAgICAgICAgaWYgKHNlY3Rpb25ZICsgY29udGVudEhlaWdodCA+IHBhZ2VIZWlnaHQgLSBtYXJnaW5Cb3R0b20pIHtcbiAgICAgICAgICAgICAgLy8gQ29udGVudCB3b24ndCBmaXQgb24gY3VycmVudCBwYWdlXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSBsaW5lcyB3aWxsIGZpdCBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gcGFnZUhlaWdodCAtIG1hcmdpbkJvdHRvbSAtIHNlY3Rpb25ZO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lc1BlclBhZ2UgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIDcpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGxpbmVzUGVyUGFnZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYXMgbWFueSBsaW5lcyBhcyB3aWxsIGZpdCBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhZ2VMaW5lcyA9IHNwbGl0Q29udGVudC5zbGljZSgwLCBsaW5lc1BlclBhZ2UpO1xuICAgICAgICAgICAgICAgIGRvYy50ZXh0KGZpcnN0UGFnZUxpbmVzLCAxNCwgc2VjdGlvblkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBZGQgYSBuZXcgcGFnZSBmb3IgcmVtYWluaW5nIGNvbnRlbnRcbiAgICAgICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgICAgICAgICAgICBkb2MudGV4dChgUGFnZSAke3BhZ2VOdW1iZXJ9YCwgcGFnZVdpZHRoIC0gMjAsIHBhZ2VIZWlnaHQgLSAxMCk7XG4gICAgICAgICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHJlbWFpbmluZyBjb250ZW50IG9uIG5ldyBwYWdlXG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0xpbmVzID0gc3BsaXRDb250ZW50LnNsaWNlKGxpbmVzUGVyUGFnZSA+IDAgPyBsaW5lc1BlclBhZ2UgOiAwKTtcbiAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uWSA9IDIwOyAvLyBSZXNldCBwb3NpdGlvbiB0byB0b3Agb2YgbmV3IHBhZ2VcbiAgICAgICAgICAgICAgICBkb2MudGV4dChyZW1haW5pbmdMaW5lcywgMTQsIHNlY3Rpb25ZKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uWSArPSByZW1haW5pbmdMaW5lcy5sZW5ndGggKiA3ICsgMTA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvblkgPSAyMDsgLy8gUmVzZXQgcG9zaXRpb24gdG8gdG9wIG9mIG5ldyBwYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIENvbnRlbnQgZml0cyBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgZG9jLnRleHQoc3BsaXRDb250ZW50LCAxNCwgc2VjdGlvblkpO1xuICAgICAgICAgICAgICBzZWN0aW9uWSArPSBjb250ZW50SGVpZ2h0ICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhhbmRsZSBjb2RlIGV4YW1wbGVzIHdpdGggc3BlY2lhbCBmb3JtYXR0aW5nXG4gICAgICAgICAgICBpZiAoc2VjdGlvbkNvbnRlbnQuaW5jbHVkZXMoJ2BgYCcpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRQYXJ0cyA9IHNlY3Rpb25Db250ZW50LnNwbGl0KC9gYGBcXHcqXFxuLyk7XG4gICAgICAgICAgICAgIGxldCBjb250ZW50WSA9IHNlY3Rpb25ZO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb250ZW50UGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgdGV4dFxuICAgICAgICAgICAgICAgICAgY29uc3QgcmVndWxhclRleHQgPSBjb250ZW50UGFydHNbal0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlZ3VsYXJUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0UmVndWxhciA9IGRvYy5zcGxpdFRleHRUb1NpemUocmVndWxhclRleHQsIHBhZ2VXaWR0aCAtIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNvbnRlbnQgd2lsbCBmaXQgb24gY3VycmVudCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50WSArIChzcGxpdFJlZ3VsYXIubGVuZ3RoICogNykgPiBwYWdlSGVpZ2h0IC0gbWFyZ2luQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbmV3IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwYWdlIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9jLnRleHQoYFBhZ2UgJHtwYWdlTnVtYmVyfWAsIHBhZ2VXaWR0aCAtIDIwLCBwYWdlSGVpZ2h0IC0gMTApO1xuICAgICAgICAgICAgICAgICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMik7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFkgPSAyMDsgLy8gUmVzZXQgcG9zaXRpb24gdG8gdG9wIG9mIG5ldyBwYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRvYy50ZXh0KHNwbGl0UmVndWxhciwgMTQsIGNvbnRlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFkgKz0gc3BsaXRSZWd1bGFyLmxlbmd0aCAqIDc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIENvZGUgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgY29uc3QgY29kZVRleHQgPSBjb250ZW50UGFydHNbal0uc3BsaXQoJ2BgYCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdENvZGUgPSBkb2Muc3BsaXRUZXh0VG9TaXplKGNvZGVUZXh0LCBwYWdlV2lkdGggLSA0MCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVIZWlnaHQgPSBzcGxpdENvZGUubGVuZ3RoICogNyArIDEwO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY29kZSBibG9jayB3aWxsIGZpdCBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRZICsgY29kZUhlaWdodCA+IHBhZ2VIZWlnaHQgLSBtYXJnaW5Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBuZXcgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IGRvYy5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb2MudGV4dChgUGFnZSAke3BhZ2VOdW1iZXJ9YCwgcGFnZVdpZHRoIC0gMjAsIHBhZ2VIZWlnaHQgLSAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50WSA9IDIwOyAvLyBSZXNldCBwb3NpdGlvbiB0byB0b3Agb2YgbmV3IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyBhIGxpZ2h0IGdyYXkgYmFja2dyb3VuZCBmb3IgY29kZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc2V0RmlsbENvbG9yKDI0MCwgMjQwLCAyNDApO1xuICAgICAgICAgICAgICAgICAgICBkb2MucmVjdCgxNCwgY29udGVudFkgLSA1LCBwYWdlV2lkdGggLSAyOCwgY29kZUhlaWdodCwgJ0YnKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29kZSB3aXRoIG1vbm9zcGFjZSBmb250XG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRGb250KCdjb3VyaWVyJywgJ25vcm1hbCcpO1xuICAgICAgICAgICAgICAgICAgICBkb2MudGV4dChzcGxpdENvZGUsIDIwLCBjb250ZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRZICs9IGNvZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlY3Rpb25ZID0gY29udGVudFkgKyAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY3VycmVudFlQb3NpdGlvbiA9IHNlY3Rpb25ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvciBzaW1wbGUgdW5zdHJ1Y3R1cmVkIHJlbWVkaWF0aW9uIHRleHRcbiAgICAgICAgICAvLyBDbGVhbiB1cCBhbnkgbWFya2Rvd24gZm9ybWF0dGluZyBmcm9tIHVuc3RydWN0dXJlZCB0ZXh0XG4gICAgICAgICAgcmVtZWRpYXRpb25UZXh0ID0gcmVtZWRpYXRpb25UZXh0LnJlcGxhY2UoL14jIyNcXHMrL2dtLCAnJyk7XG4gICAgICAgICAgcmVtZWRpYXRpb25UZXh0ID0gcmVtZWRpYXRpb25UZXh0LnJlcGxhY2UoL14jIyMjXFxzKy9nbSwgJycpO1xuICAgICAgICAgIHJlbWVkaWF0aW9uVGV4dCA9IHJlbWVkaWF0aW9uVGV4dC5yZXBsYWNlKC9eI1xccysvZ20sICcnKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBzcGxpdFJlbWVkaWF0aW9uID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShyZW1lZGlhdGlvblRleHQsIHBhZ2VXaWR0aCAtIDI4KTtcbiAgICAgICAgICBjb25zdCByZW1lZGlhdGlvbkhlaWdodCA9IHNwbGl0UmVtZWRpYXRpb24ubGVuZ3RoICogNztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiByZW1lZGlhdGlvbiB0ZXh0IHdpbGwgZml0IG9uIGN1cnJlbnQgcGFnZVxuICAgICAgICAgIGlmIChjdXJyZW50WVBvc2l0aW9uICsgcmVtZWRpYXRpb25IZWlnaHQgPiBwYWdlSGVpZ2h0IC0gMjApIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSBsaW5lcyB3aWxsIGZpdCBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IHBhZ2VIZWlnaHQgLSAyMCAtIGN1cnJlbnRZUG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBsaW5lc1BlclBhZ2UgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIDcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGluZXNQZXJQYWdlID4gMCkge1xuICAgICAgICAgICAgICAvLyBBZGQgYXMgbWFueSBsaW5lcyBhcyB3aWxsIGZpdCBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYWdlTGluZXMgPSBzcGxpdFJlbWVkaWF0aW9uLnNsaWNlKDAsIGxpbmVzUGVyUGFnZSk7XG4gICAgICAgICAgICAgIGRvYy50ZXh0KGZpcnN0UGFnZUxpbmVzLCAxNCwgY3VycmVudFlQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBwYWdlIGZvciByZW1haW5pbmcgY29udGVudFxuICAgICAgICAgICAgZG9jLmFkZFBhZ2UoKTtcbiAgICAgICAgICAgIC8vIEFkZCBwYWdlIG51bWJlclxuICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IGRvYy5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgICAgICAgICAgZG9jLnRleHQoYFBhZ2UgJHtwYWdlTnVtYmVyfWAsIHBhZ2VXaWR0aCAtIDIwLCBwYWdlSGVpZ2h0IC0gMTApO1xuICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCByZW1haW5pbmcgY29udGVudCBvbiBuZXcgcGFnZVxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTGluZXMgPSBzcGxpdFJlbWVkaWF0aW9uLnNsaWNlKGxpbmVzUGVyUGFnZSA+IDAgPyBsaW5lc1BlclBhZ2UgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gPSAyMDsgLy8gUmVzZXQgcG9zaXRpb24gdG8gdG9wIG9mIG5ldyBwYWdlXG4gICAgICAgICAgICAgIGRvYy50ZXh0KHJlbWFpbmluZ0xpbmVzLCAxNCwgY3VycmVudFlQb3NpdGlvbik7XG4gICAgICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gKz0gcmVtYWluaW5nTGluZXMubGVuZ3RoICogNztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gPSAyMDsgLy8gUmVzZXQgcG9zaXRpb24gdG8gdG9wIG9mIG5ldyBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnRlbnQgZml0cyBvbiBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIGRvYy50ZXh0KHNwbGl0UmVtZWRpYXRpb24sIDE0LCBjdXJyZW50WVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRZUG9zaXRpb24gKz0gcmVtZWRpYXRpb25IZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEFkZCBmb290ZXIgd2l0aCBnZW5lcmF0aW9uIGRhdGVcbiAgY29uc3QgcGFnZUNvdW50ID0gZG9jLmdldE51bWJlck9mUGFnZXMoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcGFnZUNvdW50OyBpKyspIHtcbiAgICBkb2Muc2V0UGFnZShpKTtcbiAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IoMTAwLCAxMDAsIDEwMCk7IC8vIEdyYXkgY29sb3JcbiAgICBkb2MudGV4dChgUmVwb3J0IGdlbmVyYXRlZCBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKX1gLCAxNCwgZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpIC0gMTApO1xuICB9XG4gIFxuICAvLyBSZXR1cm4gdGhlIFBERiBhcyBhIGJsb2JcbiAgcmV0dXJuIGRvYy5vdXRwdXQoJ2Jsb2InKTtcbn07Il0sIm5hbWVzIjpbImpzUERGIiwiYXV0b1RhYmxlIiwiZ2VuZXJhdGVQREZSZXBvcnQiLCJzY2FuIiwidnVsbmVyYWJpbGl0aWVzIiwiZG9jIiwicGFnZVdpZHRoIiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImdldFdpZHRoIiwic2V0Rm9udFNpemUiLCJzZXRUZXh0Q29sb3IiLCJ0ZXh0IiwiYWxpZ24iLCJ1cmwiLCJ0YXJnZXQiLCJzY2FuX3R5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsInN0YXJ0VGltZVZhbHVlIiwic3RhcnRfdGltZSIsInN0YXJ0ZWRfYXQiLCJlbmRUaW1lVmFsdWUiLCJlbmRfdGltZSIsImNvbXBsZXRlZF9hdCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJnZXRUaW1lIiwidG9GaXhlZCIsInN1bW1hcnkiLCJ0b3RhbF92dWxuZXJhYmlsaXRpZXMiLCJzZXZlcml0eV9jb3VudHMiLCJzZXZlcml0eUNvdW50cyIsInN0YXJ0WSIsImhlYWQiLCJib2R5IiwiY3JpdGljYWwiLCJ0b1N0cmluZyIsImhpZ2giLCJtZWRpdW0iLCJsb3ciLCJpbmZvIiwidGhlbWUiLCJoZWFkU3R5bGVzIiwiZmlsbENvbG9yIiwiY29sdW1uU3R5bGVzIiwiY2VsbFdpZHRoIiwiaGFsaWduIiwibGVuZ3RoIiwiY3VycmVudFkiLCJwcmV2aW91c0F1dG9UYWJsZSIsImZpbmFsWSIsInRhYmxlUm93cyIsIm1hcCIsInZ1bG4iLCJuYW1lIiwic2V2ZXJpdHkiLCJsb2NhdGlvbiIsImRlc2NyaXB0aW9uIiwic3Vic3RyaW5nIiwiZGlkRHJhd1BhZ2UiLCJkYXRhIiwicGFnZU51bWJlciIsImdldE51bWJlck9mUGFnZXMiLCJnZXRIZWlnaHQiLCJmb3JFYWNoIiwiaW5kZXgiLCJhZGRQYWdlIiwiY3dlX2lkIiwiY3Zzc19zY29yZSIsInNwbGl0RGVzY3JpcHRpb24iLCJzcGxpdFRleHRUb1NpemUiLCJjdXJyZW50WVBvc2l0aW9uIiwiZXZpZGVuY2UiLCJzcGxpdEV2aWRlbmNlIiwicmVtZWRpYXRpb24iLCJwYWdlSGVpZ2h0IiwicmVtZWRpYXRpb25UZXh0IiwicmVwbGFjZSIsImluY2x1ZGVzIiwic2VjdGlvbnMiLCJzcGxpdCIsImFsdFNlY3Rpb25zIiwic2VjdGlvbiIsInB1c2giLCJzZWN0aW9uWSIsIm1hcmdpbkJvdHRvbSIsImkiLCJ0cmltIiwic2VjdGlvblBhcnRzIiwic2VjdGlvblRpdGxlIiwic2VjdGlvbkNvbnRlbnQiLCJqb2luIiwic2V0Rm9udCIsInNwbGl0Q29udGVudCIsImNvbnRlbnRIZWlnaHQiLCJhdmFpbGFibGVIZWlnaHQiLCJsaW5lc1BlclBhZ2UiLCJNYXRoIiwiZmxvb3IiLCJmaXJzdFBhZ2VMaW5lcyIsInJlbWFpbmluZ0xpbmVzIiwiY29udGVudFBhcnRzIiwiY29udGVudFkiLCJqIiwicmVndWxhclRleHQiLCJzcGxpdFJlZ3VsYXIiLCJjb2RlVGV4dCIsInNwbGl0Q29kZSIsImNvZGVIZWlnaHQiLCJzZXRGaWxsQ29sb3IiLCJyZWN0Iiwic3BsaXRSZW1lZGlhdGlvbiIsInJlbWVkaWF0aW9uSGVpZ2h0IiwicGFnZUNvdW50Iiwic2V0UGFnZSIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/pdfGenerator.ts\n"));

/***/ })

});